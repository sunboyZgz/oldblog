<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CRA-combine-tailwind2</title>
    <url>/2021/04/30/combine-tailwind2/</url>
    <content><![CDATA[<h2 id="在create-react-app-版本为4-0-3-结合tailwindcss2"><a href="#在create-react-app-版本为4-0-3-结合tailwindcss2" class="headerlink" title="在create-react-app 版本为4.0.3 结合tailwindcss2"></a>在create-react-app 版本为4.0.3 结合tailwindcss2</h2><h4 id="注意：本人测试时create-react-app-版本为4-0-3-在往后的版本中，对于postcss8可能已经支持"><a href="#注意：本人测试时create-react-app-版本为4-0-3-在往后的版本中，对于postcss8可能已经支持" class="headerlink" title="注意：本人测试时create-react-app 版本为4.0.3,在往后的版本中，对于postcss8可能已经支持"></a>注意：本人测试时create-react-app 版本为4.0.3,在往后的版本中，对于postcss8可能已经支持</h4><p>最近在准备与其他同学接手一个简单的开源项目，其中需要在项目中增加一个昼夜主题切换的功能</p>
<p>这时我想到了两套方案：</p>
<ul>
<li>两套css</li>
<li>更换 css 变量值</li>
</ul>
<p>但是作为一个css功力并不是难么强的前端工程师，这使得我无比头疼，因此我决定采用一个css库，在四处转悠之后发现tailwindcss具有对昼夜更换功能的支持，因此我决定在项目中进行整合</p>
<p>按照官方所述，我进行了如下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D tailwindcss@latest postcss@latest autoprefixer@latest</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    tailwindcss: &#123;&#125;,</span><br><span class="line">    autoprefixer: &#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx tailwindcss init</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tailwind.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  purge: [],</span><br><span class="line">  darkMode: <span class="literal">false</span>, <span class="comment">// or &#x27;media&#x27; or &#x27;class&#x27;</span></span><br><span class="line">  theme: &#123;</span><br><span class="line">    extend: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  variants: &#123;&#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后在命令行输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>


<p>果不其然整合出了问题，具体报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: PostCSS plugin tailwindcss requires PostCSS 8.</span><br></pre></td></tr></table></figure>


<p>ok，针对CRA项目中的 PostCSS plugin tailwindcss requires PostCSS 8，我们可以进行问题的解决，如果是其他报错，本解决方案可能并不适用</p>
<p>首先，分析问题，npm run start 是对react-scripts 中 start.js的调用，采用的配置环境也是该<code>node_module/react-scripts/config</code>下的webpack.config.js。因此之后我们需要对此文件进行修改,</p>
<p>简单阅读<code>start.js-&gt;env.js-&gt;paths.js</code>的源码我们可以发现，工作目录的根目录，为了方便文件的修改我使用</p>
<p><code>npm run eject</code>弹出了配置相关内容</p>
<p>逛了一遍github，我终于找到了目前可行的方案，至于在之后项目进行开发的过程中能否有效还不清楚</p>
<h5 id="修改webpack-config-js-package-json"><a href="#修改webpack-config-js-package-json" class="headerlink" title="修改webpack.config.js , package.json"></a>修改webpack.config.js , package.json</h5><p><a href="https://github.com/facebook/create-react-app/pull/10003/files">原文链接：https://github.com/facebook/create-react-app/pull/10003/files</a></p>
<p>修改完成执行<code>yarn install </code>因为create-react-app默认使用yarn工具</p>
<p>如果你切换为npm,请执行 <code>npm install</code></p>
<p>注意虽然webpack.config.js在<code>&#123;$project-root&#125;/config</code>目录下但是我们的 <code>postcss.config.js</code>因该放在<code>&#123;$project-root&#125;</code>目录下</p>
<p>ok,在项目中加入 tailwindcss utility class name并执行npm run start进行测试</p>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/combine-tailwind/Snipaste_2021-04-30_18-00-47.png"></p>
<p>功能实现</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>一文入门Babel</title>
    <url>/2021/10/17/babel-base/</url>
    <content><![CDATA[<h1 id="babel之路的起点"><a href="#babel之路的起点" class="headerlink" title="babel之路的起点"></a>babel之路的起点</h1><h3 id="开始的起点"><a href="#开始的起点" class="headerlink" title="开始的起点"></a>开始的起点</h3><blockquote>
<p>因为最近开始学习babel，我想简单了解一下一个编译工具工作原理。又因为编译功能这一块来说还是相对抽象了一点。所以我找到了一个学习的项目。</p>
</blockquote>
<p>学习项目：<a href="https://github.com/jamiebuilds/the-super-tiny-compiler">https://github.com/jamiebuilds/the-super-tiny-compiler</a></p>
<p>说是一个超小的编译器不如说是一个简单编译器工作原理的教学，毕竟官网就有这么一句话：<code>This is an ultra-simplified example of all the major pieces of a modern compiler written in easy to read JavaScript.</code>，同时我们通过这些简短的源码我们可以发现作者在其中写了很多的注释，非常易于理解。</p>
<p>项目作者通过<code>lisp</code>代码到<code>js</code>代码的转换简洁明了地让我们知道编译器的核心部份。</p>
<h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><p>在编译的过程中有两项非常重要的操作：<code>Lexical Analysis</code>(词法分析)与<code>Syntactic Analysis</code>(语法分析)</p>
<p><code>tokenizer</code>,<code>parser</code>, <code>transformer</code>,<code>generator</code></p>
<h4 id="tokenizer"><a href="#tokenizer" class="headerlink" title="tokenizer"></a>tokenizer</h4><p>可以说是非常简单的词法分析</p>
<p><img src="C:/Users/19454/AppData/Roaming/Typora/typora-user-images/image-20211017171627497.png" alt="image-20211017171627497"></p>
<h4 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h4><p>语法分析，这个项目中的语法分析相对较为简单，没有多个操作符表达式的分析，主要针对以上的<code>closing parenthesis</code>(闭合括号进行不同的分析)。</p>
<p>这里主要是吧上面单个的字符对象进行关联性的组合，生成AST。</p>
<p><img src="C:/Users/19454/AppData/Roaming/Typora/typora-user-images/image-20211017172643478.png" alt="image-20211017172643478"></p>
<h4 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h4><p>转换器，将语法树进行修改后再放给<code>generator</code>。其中主要的转换控制由<code>vistor</code>提供条件（可以是节点的约束，或者节点访问前后的钩子函数），具体会在后面的babel基本知识中讲到。</p>
<p><img src="C:/Users/19454/AppData/Roaming/Typora/typora-user-images/image-20211017174229155.png" alt="image-20211017174229155"></p>
<p>这里为什么要在<code>CallExpression</code>对象外包一个<code>ExpressionStatement</code>，注释中说法是对标js通常语法块的形式。</p>
<p>在源码中核心功能函数为<code>traverseNode</code></p>
<h4 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h4><p>生成器:依据最终文件的代码语法以及AST的节点关系来进行code生成</p>
<p><img src="C:/Users/19454/AppData/Roaming/Typora/typora-user-images/image-20211017181851504.png" alt="image-20211017181851504"></p>
<p>以上就是从<code>Lisp</code>语法到<code>js</code>语法的简答编译。</p>
<p>这里没有贴出什么重要代码的理解是因为作者将代码写得非常易懂，只需要花费很少的时间你就能通过js理解编译器核心的工作内容。</p>
<h1 id="babel入门知识"><a href="#babel入门知识" class="headerlink" title="babel入门知识"></a>babel入门知识</h1><h4 id="babel是什么？"><a href="#babel是什么？" class="headerlink" title="babel是什么？"></a>babel是什么？</h4><p>Babel 是一个通用的 JavaScript 多用途编译器，再简单一点babel是个编译器。</p>
<h4 id="babel是怎么样实现各式各样的需求的呢？"><a href="#babel是怎么样实现各式各样的需求的呢？" class="headerlink" title="babel是怎么样实现各式各样的需求的呢？"></a>babel是怎么样实现各式各样的需求的呢？</h4><p>通过插件，babel有一个庞大的插件库，同时babel提供了我们自定义插件的能力。</p>
<p>更多的如何配置<code>.babelrc</code>或者如何使用<code>babel-cli</code>可以在babel的官网或者<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/user-handbook.md">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/user-handbook.md</a> 进行了解。</p>
<h2 id="怎么去写一个自己的插件？"><a href="#怎么去写一个自己的插件？" class="headerlink" title="怎么去写一个自己的插件？"></a>怎么去写一个自己的插件？</h2><p>这里是esTree概况：<a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md#node-objects">https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md#node-objects</a>，其中最上面的目录以层级关系展示了各个节点类型之间的关系。</p>
<p>下面说说写一个插件的基本知识</p>
<h3 id="插件基本知识"><a href="#插件基本知识" class="headerlink" title="插件基本知识"></a>插件基本知识</h3><p>babel在做文件<code>transfer</code>时存在三个阶段：解析，转换，生成文件</p>
<h4 id="Visitors（访问者）"><a href="#Visitors（访问者）" class="headerlink" title="Visitors（访问者）"></a><strong>Visitors</strong>（访问者）</h4><p>这是babel中使用的访问节点的一个设计模式。</p>
<p>访问者模式的使用场景：</p>
<ol>
<li>对象结构比较稳定，但经常需要在此对象结构上定义新的操作。</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ol>
<p>在访问node时，babel提供给我们两个时机。</p>
<h4 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h4><p>一个Path对象代表了两个Node对象之间的关系。同时Paths对象是响应式的当节点发生改变可能会引起他的改变。</p>
<p>当我们使用我们的babel中访问者对象的<code>Identifier</code>方法时，我们实际上是在访问Path对象而不是Node（Node不存在与其他同级父级节点的关系），与同级父级节点的关系通过path表达。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyVisitor = &#123;</span><br><span class="line">  <span class="function"><span class="title">Identifier</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Visiting: &quot;</span> + path.node.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a + b + c;</span><br><span class="line">path.traverse(MyVisitor);</span><br><span class="line"><span class="comment">//result</span></span><br><span class="line">Visiting: a</span><br><span class="line">Visiting: b</span><br><span class="line">Visiting: c</span><br></pre></td></tr></table></figure>
<h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>作用域之间的关系</p>
<h3 id="Babel-API"><a href="#Babel-API" class="headerlink" title="Babel API"></a>Babel API</h3><blockquote>
<p>Babel is actually a collection of modules. In this section we’ll walk through the major ones, explaining what they do and how to use them.(这句话讲述了babel的本质就是一堆模块)</p>
</blockquote>
<p>更加详细的文档位置：<a href="https://babeljs.io/docs/en/babel-core/">https://babeljs.io/docs/en/babel-core/</a></p>
<h4 id="babel-parser"><a href="#babel-parser" class="headerlink" title="@babel-parser"></a>@babel-parser</h4><p><code>sourceType</code> 默认是 <code>&quot;script&quot;</code> ，如果解析过程中遇到 <code>import</code> or <code>export</code>会报错，所以当需要<code>import</code>或者<code>export</code>时，将<code>sourceType</code>进行修改为”module”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parser.parse(code, &#123;</span><br><span class="line">  sourceType: <span class="string">&quot;module&quot;</span>, <span class="comment">// default: &quot;script&quot;</span></span><br><span class="line">  plugins: [<span class="string">&quot;jsx&quot;</span>] <span class="comment">// default: []</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="babel-traverse"><a href="#babel-traverse" class="headerlink" title="@babel-traverse"></a>@babel-traverse</h4><p>主要维护修改esTree的功能</p>
<h4 id="babel-types"><a href="#babel-types" class="headerlink" title="@babel-types"></a>@babel-types</h4><p>babel提供的高效操作库，提供了一些功能函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&quot;@babel/traverse&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&quot;@babel/types&quot;</span>;</span><br><span class="line"></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="function"><span class="title">enter</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.isIdentifier(path.node, &#123; <span class="attr">name</span>: <span class="string">&quot;n&quot;</span> &#125;)) &#123;<span class="comment">//isIdentifier就是我们path.node.type == &quot;Identifier&quot;</span></span><br><span class="line">      path.node.name = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="babel-generator"><a href="#babel-generator" class="headerlink" title="@babel-generator"></a>@babel-generator</h4><p>将AST语法树转换成我们书写的源码形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> t <span class="keyword">from</span> <span class="string">&quot;@babel/types&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">&quot;@babel/generator&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  generate.default(</span><br><span class="line">    t.binaryExpression(<span class="string">&quot;*&quot;</span>, t.identifier(<span class="string">&quot;a&quot;</span>), t.identifier(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="babel-template"><a href="#babel-template" class="headerlink" title="@babel-template"></a>@babel-template</h4><p>一个方便我们编写语法树的功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> t <span class="keyword">from</span> <span class="string">&quot;@babel/types&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">&quot;@babel/generator&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> template <span class="keyword">from</span> <span class="string">&quot;@babel/template&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> buildRequire = template.default(<span class="string">`</span></span><br><span class="line"><span class="string">  var IMPORT_NAME = require(SOURCE);</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="keyword">const</span> ast = buildRequire(&#123;</span><br><span class="line">  IMPORT_NAME: t.identifier(<span class="string">&quot;myModule&quot;</span>),</span><br><span class="line">  SOURCE: t.stringLiteral(<span class="string">&quot;my-module&quot;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> pathname = <span class="string">&quot;./output.js&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!fs.existsSync(pathname)) &#123;</span><br><span class="line">  fs.writeFile(pathname, generate.default(ast).code, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">console</span>.warn(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的程序，我们会在<code>output.js</code>文件中看到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">&quot;my-module&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="babel-core"><a href="#babel-core" class="headerlink" title="@babel-core"></a>@babel-core</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> t = babel.types;</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`foo === bar;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = babel.transformSync(code, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    &#123;</span><br><span class="line">      visitor: &#123;</span><br><span class="line">        <span class="function"><span class="title">BinaryExpression</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (path.node.operator !== <span class="string">&quot;===&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          path.node.left = t.identifier(<span class="string">&quot;sebmck&quot;</span>);</span><br><span class="line">          path.node.right = t.identifier(<span class="string">&quot;dork&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result.code);  <span class="comment">//sebmck === dork;</span></span><br></pre></td></tr></table></figure>
<p>这里我们的<code>@babel/core</code>实际上是我们上面介绍的的许多微小插件的集合，这里体现的就是的babel微内核的特点，其功能均由插件拓展而来，内核仅提供核心功能。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; GeneratorOptions &#125; <span class="keyword">from</span> <span class="string">&#x27;@babel/generator&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ParserOptions &#125; <span class="keyword">from</span> <span class="string">&#x27;@babel/parser&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> template <span class="keyword">from</span> <span class="string">&#x27;@babel/template&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> traverse, &#123; Hub, NodePath, Scope, Visitor &#125; <span class="keyword">from</span> <span class="string">&#x27;@babel/traverse&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; ParserOptions, GeneratorOptions, t <span class="keyword">as</span> types, template, traverse, NodePath, Visitor &#125;;</span><br></pre></td></tr></table></figure>
<p>这段可以看出<code>@babel/core</code>导出对象的功能</p>
<h3 id="transform时的操作"><a href="#transform时的操作" class="headerlink" title="transform时的操作"></a>transform时的操作</h3><h5 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h5><p><code>path.node.property</code>：访问到节点</p>
<p><code>path.get(dotpath)</code>：访问节点的path对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">BinaryExpression</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">  path.node.left;</span><br><span class="line">  path.node.right;</span><br><span class="line">  path.node.operator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.get(<span class="string">&#x27;body.0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="检查节点的类型"><a href="#检查节点的类型" class="headerlink" title="检查节点的类型"></a>检查节点的类型</h5><p>做transform时我们通常会有一个或者说是一些我们希望更改的节点，这个时候可以用下面的方式进行检查</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">BinaryExpression</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (t.isIdentifier(path.node.left, &#123; <span class="attr">name</span>: <span class="string">&quot;n&quot;</span> &#125;)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能上等价于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">BinaryExpression</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    path.node.left != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    path.node.left.type === <span class="string">&quot;Identifier&quot;</span> &amp;&amp;</span><br><span class="line">    path.node.left.name === <span class="string">&quot;n&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检查路径（Path）类型"><a href="#检查路径（Path）类型" class="headerlink" title="检查路径（Path）类型"></a>检查路径（Path）类型</h5><h5 id="检查标识符（Identifier）是否被引用"><a href="#检查标识符（Identifier）是否被引用" class="headerlink" title="检查标识符（Identifier）是否被引用"></a>检查标识符（Identifier）是否被引用</h5><p>这里两个并没有粘上示例代码主要的原因是：这两个操作与检查节点类型十分相似，同时我们又已经了解了访问的操作。而这些检查实际上都是@babel/types包下的操作。所以只需要在实际应用中想到有这么一个操作然后查查上面发的handle-book或者babel文档就好（后者更优）</p>
<h5 id="找到特定的父路径"><a href="#找到特定的父路径" class="headerlink" title="找到特定的父路径"></a>找到特定的父路径</h5><p>有时我们需要从当前path找一个合适的父级path。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.findParent(<span class="function">(<span class="params">path</span>) =&gt;</span> path.isObjectExpression());</span><br></pre></td></tr></table></figure>
<p>这个<code>findParent()</code>就是提供一个参数为父级path的<code>callback</code>，然后不断向上遍历直到父级path满足<code>return</code> 条件</p>
<h5 id="获取同级路径"><a href="#获取同级路径" class="headerlink" title="获取同级路径"></a>获取同级路径</h5><p>在一个代码块或文件中，我们经常写一些同级的节点。所以针对一个path寻找他的同级操作也是需要的。与之相关的有以下操作。</p>
<ul>
<li><code>path.inList</code>：检查一个path是否在一个同级列表中，相当于检查是否有同级元素</li>
<li><code>path.key</code>：检查一个path在<code>Container</code>中的index(打印过的path对象的我们应该知道，container也是其中的一项信息)</li>
<li><code>path.getSibling(index)</code>：我们可以找到index代表的同级的path对象，index与path.key有关`</li>
<li><code>path.container</code>：容纳同级path的数组</li>
<li><code>path.listKey</code>：获取容器的key</li>
</ul>
<h5 id="停止path遍历"><a href="#停止path遍历" class="headerlink" title="停止path遍历"></a>停止path遍历</h5><ol>
<li><p>写一个停止的return条件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">    <span class="function"><span class="title">xxxExpression</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用<code>path.skip()</code>、<code>path.stop()</code>，我暂时还不知道怎么用。</p>
<ol>
<li>ok，<code>path.stop()</code>的情形碰到了，比如说我的访问者对象是访问一个<code>StringLiteral</code>但是我在对这个p作时又生成了<code>StringLiteral</code>，这种情况因为我们的<code>StringLiteral</code>会被马上加到AST中，然后就又会被访问者对象访问到，会一直循环，我们只需要在最后调用<code>path.stop()</code>即可,下面这段代码已经可以充分说明问题了，虽然这是我写错的时候写出来的</li>
<li>一个demo把两个方法调用都搞明白了，如果调用<code>path.stop()</code>,针对当前访问方法不再继续，会停止访问者当前层级树节点遍历，然后就会像树遍历一样一层一层退出，所以调用<code>path.stop()</code>,<code>&#39;Hello &#39; + name</code>中的<code>name</code>不会被反转。而如果调用<code>path.skip()</code>,就会跳过接下来对于<code>StringLiteral</code>的遍历，所以程序能够访问到<code>name</code>并根据代码把<code>name</code>更换成<code>eman</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> t = babel.types;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">function greet(name) &#123;</span></span><br><span class="line"><span class="string">  return &#x27;Hello &#x27; + name;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">console.log(greet(&#x27;abao&#x27;));</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="keyword">const</span> output = babel.transformSync(code, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myCustomPlugin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        visitor: &#123;</span><br><span class="line">          <span class="function"><span class="title">StringLiteral</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> concat = path.node.value</span><br><span class="line">              .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">              .map(<span class="function">(<span class="params">c</span>) =&gt;</span> babel.types.stringLiteral(c))</span><br><span class="line">              .reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> babel.types.binaryExpression(<span class="string">&quot;+&quot;</span>, prev, curr);</span><br><span class="line">              &#125;);</span><br><span class="line">            path.replaceWith(concat);</span><br><span class="line">            path.skip();</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="title">Identifier</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              t.isFunctionDeclaration(path.parent) ||</span><br><span class="line">              t.isCallExpression(path.parent) ||</span><br><span class="line">              t.isBinaryExpression(path.parent)</span><br><span class="line">            ) &#123;</span><br><span class="line">              path.node.name = path.node.name.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * output.code的输出结果：</span></span><br><span class="line"><span class="comment"> * function teerg(eman) &#123;</span></span><br><span class="line"><span class="comment"> *  return &quot;H&quot; + &quot;e&quot; + &quot;l&quot; + &quot;l&quot; + &quot;o&quot; + &quot; &quot; + eman;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * console.log(teerg(&quot;a&quot; + &quot;b&quot; + &quot;a&quot; + &quot;o&quot;));</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> pathname = <span class="string">&quot;./out-reverse.js&quot;</span>;</span><br><span class="line">fs.writeFile(pathname, output.code, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.warn(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="增、删、改节点StringLiteral"><a href="#增、删、改节点StringLiteral" class="headerlink" title="增、删、改节点StringLiteral"></a>增、删、改节点StringLiteral</h5></li>
</ol>
<p>看一下代码就知道怎么回事了，还有一些其他的更换方式大同小异都在这个链接里：<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#manipulation">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#manipulation</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">BinaryExpression</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">  path.replaceWith(</span><br><span class="line">    t.binaryExpression(<span class="string">&quot;**&quot;</span>, path.node.left, t.numberLiteral(<span class="number">2</span>))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="scope（作用域）"><a href="#scope（作用域）" class="headerlink" title="scope（作用域）"></a>scope（作用域）</h4><h5 id="检查作用域与变量的关系"><a href="#检查作用域与变量的关系" class="headerlink" title="检查作用域与变量的关系"></a>检查作用域与变量的关系</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.scope.hasBinding(<span class="string">&quot;n&quot;</span>)</span><br><span class="line"><span class="comment">// 检查作用域中（会沿作用域链查找）是否有n变量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.scope.hasOwnBinding(<span class="string">&quot;n&quot;</span>)</span><br><span class="line"><span class="comment">// 只在自己的作用域中查找是否有n变量</span></span><br></pre></td></tr></table></figure>
<p>这里主要handle-book说的有点含糊，我也没有去看官文。我通过下面的例子证实了我的猜想。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">function qq() &#123;</span></span><br><span class="line"><span class="string">  let a = 1;</span></span><br><span class="line"><span class="string">  function cb() &#123;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = babel.transformSync(code, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    &#123;</span><br><span class="line">      visitor: &#123;</span><br><span class="line">        <span class="function"><span class="title">FunctionDeclaration</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(path.scope.hasOwnBinding(<span class="string">&quot;a&quot;</span>)); <span class="comment">//改成path.scope.hasBinding后再次证实一次</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="提升变量声明至父级作用域"><a href="#提升变量声明至父级作用域" class="headerlink" title="提升变量声明至父级作用域"></a>提升变量声明至父级作用域</h5><p>有时你可能想要推送一个` VariableDeclaration &lt;/&gt;，这样你就可以分配给它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">FunctionDeclaration</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = path.scope.generateUidIdentifierBasedOnNode(path.node.id);</span><br><span class="line">  path.remove();</span><br><span class="line">  path.scope.parent.push(&#123; id, <span class="attr">init</span>: path.node &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- function square(n) &#123;</span></span><br><span class="line"><span class="deletion">-   return n * n;</span></span><br><span class="line"><span class="addition">+ function square(x) &#123;</span></span><br><span class="line"><span class="addition">+   return x * x;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>我认为最佳的实践肯定是一些小项目，handle-book的应该被称为项目中比较实用的技巧。</p>
<h5 id="1-创建帮助函数"><a href="#1-创建帮助函数" class="headerlink" title="1.创建帮助函数"></a>1.创建帮助函数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAssignment</span>(<span class="params">node</span>) </span>&#123;<span class="comment">//判断是否为赋值操作</span></span><br><span class="line">  <span class="keyword">return</span> node &amp;&amp; node.operator === opts.operator + <span class="string">&quot;=&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildAssignment</span>(<span class="params">left, right</span>) </span>&#123;<span class="comment">//写了一个helper函数方便之后调用只需要传两个参数</span></span><br><span class="line">  <span class="keyword">return</span> t.assignmentExpression(<span class="string">&quot;=&quot;</span>, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-尽可能合并访问者对象"><a href="#2-尽可能合并访问者对象" class="headerlink" title="2.尽可能合并访问者对象"></a>2.尽可能合并访问者对象</h5><p>因为一个traverse操作的成本比较高，将多个表达式的匹配放在一个visitor中可以减少调用traverse的次数</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-path.traverse(&#123;</span></span><br><span class="line"><span class="deletion">-  Identifier(path) &#123;</span></span><br><span class="line"><span class="deletion">-    // ...</span></span><br><span class="line"><span class="deletion">-  &#125;</span></span><br><span class="line"><span class="deletion">-&#125;);</span></span><br><span class="line"><span class="deletion">-path.traverse(&#123;</span></span><br><span class="line"><span class="deletion">-  BinaryExpression(path) &#123;</span></span><br><span class="line"><span class="deletion">-    // ...</span></span><br><span class="line"><span class="deletion">-  &#125;</span></span><br><span class="line"><span class="deletion">-&#125;);</span></span><br><span class="line"><span class="addition">+path.traverse(&#123;</span></span><br><span class="line"><span class="addition">+  Identifier(path) &#123;</span></span><br><span class="line"><span class="addition">+    // ...</span></span><br><span class="line"><span class="addition">+  &#125;,</span></span><br><span class="line"><span class="addition">+  BinaryExpression(path) &#123;</span></span><br><span class="line"><span class="addition">+    // ...</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+&#125;);</span></span><br></pre></td></tr></table></figure>
<h5 id="3-在可以不用traverse的时候尽可能不用"><a href="#3-在可以不用traverse的时候尽可能不用" class="headerlink" title="3.在可以不用traverse的时候尽可能不用"></a>3.在可以不用traverse的时候尽可能不用</h5><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-const nestedVisitor = &#123;</span></span><br><span class="line"><span class="deletion">-  Identifier(path) &#123;</span></span><br><span class="line"><span class="deletion">-    // ...</span></span><br><span class="line"><span class="deletion">-  &#125;</span></span><br><span class="line"><span class="deletion">-&#125;;</span></span><br><span class="line">const MyVisitor = &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line"><span class="deletion">-   path.get(&#x27;params&#x27;).traverse(nestedVisitor); //这个traverse是可以不用调用的</span></span><br><span class="line"><span class="addition">+	path.node.params.forEach(function() &#123;...&#125;);</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="4-优化嵌套的vistors"><a href="#4-优化嵌套的vistors" class="headerlink" title="4.优化嵌套的vistors"></a>4.优化嵌套的vistors</h5><p>其实就是尽可能减少同一种功能的visitor的重复创建。</p>
<p>比如在函数局部作用域的声明，我们可以将其声明放在功能函数体之外。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">const MyVisitor = &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    path.traverse(&#123; //path.traverse中传入的就是一个每次访问MyVisitor就会重复创建的一个visitor对象</span><br><span class="line">      Identifier(path) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到这里第一阶段算是结束了，之后就要真正进入实战提升自己了。</p>
<p>更多入门级的操作也可以在这个链接中找到：<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md</a></p>
]]></content>
      <categories>
        <category>babel</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>初探mustache</title>
    <url>/2021/01/27/hello-mustache/</url>
    <content><![CDATA[<h2 id="寒假的第一次源码阅读，在写完一个极其简单的mustache之后我决定，欣赏一下“原文的魅力”，同时记录一下自己第一次分享理解的过程"><a href="#寒假的第一次源码阅读，在写完一个极其简单的mustache之后我决定，欣赏一下“原文的魅力”，同时记录一下自己第一次分享理解的过程" class="headerlink" title="寒假的第一次源码阅读，在写完一个极其简单的mustache之后我决定，欣赏一下“原文的魅力”，同时记录一下自己第一次分享理解的过程"></a>寒假的第一次源码阅读，在写完一个极其简单的mustache之后我决定，欣赏一下“原文的魅力”，同时记录一下自己第一次分享理解的过程</h2><h4 id="1-mustache-以前js大批量生成-html的方式"><a href="#1-mustache-以前js大批量生成-html的方式" class="headerlink" title="1. mustache 以前js大批量生成 html的方式"></a>1. mustache 以前js大批量生成 html的方式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. dom </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    div.innerHTML = i</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 字符传拼接</span></span><br><span class="line"><span class="keyword">let</span> htmlStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    htmlStr += <span class="string">&#x27;&lt;div&gt;&#x27;</span> + i + <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = htmlStr</span><br><span class="line"><span class="comment">// 3. join</span></span><br><span class="line"><span class="keyword">let</span> tagArr = []</span><br><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&#x27;zzzz&#x27;</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">        age: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> token = data[i]</span><br><span class="line">    tagArr.push(</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">			&lt;strong&gt;name: <span class="subst">$&#123;token[<span class="string">&#x27;name&#x27;</span>]&#125;</span>&lt;/strong&gt;</span></span><br><span class="line"><span class="string">			&lt;em&gt;age: <span class="subst">$&#123;token[<span class="string">&#x27;age&#x27;</span>]&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">		&lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = tagArr.join(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-mustache出现"><a href="#2-mustache出现" class="headerlink" title="2. mustache出现"></a>2. mustache出现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./mustache.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">	&#123;&#123;#people&#125;&#125;</span></span><br><span class="line"><span class="string">	&lt;ul&gt;</span></span><br><span class="line"><span class="string">		&lt;li&gt;</span></span><br><span class="line"><span class="string">        	name:&#123;&#123;name&#125;&#125;</span></span><br><span class="line"><span class="string">		&lt;/li&gt;</span></span><br><span class="line"><span class="string">		&lt;li&gt;</span></span><br><span class="line"><span class="string">        	age:&#123;&#123;age&#125;&#125;</span></span><br><span class="line"><span class="string">		&lt;/li&gt;</span></span><br><span class="line"><span class="string">	&lt;/ul&gt;</span></span><br><span class="line"><span class="string">	&#123;&#123;/people&#125;&#125;</span></span><br><span class="line"><span class="string">	`</span></span><br><span class="line">    <span class="keyword">const</span> view = &#123;</span><br><span class="line">        people: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&#x27;zzzz&#x27;</span>,</span><br><span class="line">                age: <span class="number">20</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">                age: <span class="number">18</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&#x27;yyy&#x27;</span>,</span><br><span class="line">                age: <span class="number">111</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">document</span>.body.innerHTML = Mustache.render(template, view)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>mustache 无疑是一个质的飞跃，这样的思维模式也被用在了当下流行的框架当中</p>
<p>那么就让我来分享我在阅读mustache的理解吧</p>
<h4 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h4><p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/mustache-learn/m1.png"></p>
<p>首先我们可以发现我们之前调用的Mustache.render 实际上是调用了 defaultWriter.render, 这个时候继续网上看，我们会看到 defaultWriter = new Writer(), 同样的这个时候回到 暴露出来的 mustache对象 ,我们可以看到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mustache.escape = escapeHtml;</span><br><span class="line">mustache.Scanner = Scanner;</span><br><span class="line">mustache.Context = Context;</span><br><span class="line">mustache.Writer = Writer;</span><br><span class="line">以及</span><br><span class="line"><span class="keyword">var</span> mustache = &#123;</span><br><span class="line">    tags: [ <span class="string">&#x27;&#123;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#125;&#x27;</span> ],</span><br><span class="line">    <span class="built_in">escape</span>: <span class="literal">undefined</span>,</span><br><span class="line">    Scanner: <span class="literal">undefined</span>,</span><br><span class="line">    Context: <span class="literal">undefined</span>,</span><br><span class="line">    Writer: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们就可以开始解剖 mustache 的源码了</p>
<h5 id="3-1-功能解析"><a href="#3-1-功能解析" class="headerlink" title="3.1 功能解析"></a>3.1 功能解析</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入到Writer中，我们可以看到一下代码</span></span><br><span class="line">Writer.prototype.render = <span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">template, view, partials, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tags = <span class="built_in">this</span>.getConfigTags(config); <span class="comment">// tags 配置 用于scanner 的 标识tag 例如 &#123;&#123;</span></span><br><span class="line">    <span class="keyword">var</span> tokens = <span class="built_in">this</span>.parse(template, tags);</span><br><span class="line">    <span class="keyword">var</span> context = (view <span class="keyword">instanceof</span> Context) ? view : <span class="keyword">new</span> Context(view, <span class="literal">undefined</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.renderTokens(tokens, context, partials, template, config);  <span class="comment">// 简单的认识 只需要关注前两个参数</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们着重观察 template 和 view 的去向， 发现 由 他们生成了  tokens  和 context，确实最后也是 调用了</span></span><br><span class="line"><span class="comment">//this.renderTokens(tokens, context) 返回了最终的结果</span></span><br><span class="line"><span class="comment">// 那从这里我们 就 引出了 this.parse 和 Context</span></span><br></pre></td></tr></table></figure>
<h5 id="3-2-this-parse-到底为何方神圣"><a href="#3-2-this-parse-到底为何方神圣" class="headerlink" title="3.2 this.parse 到底为何方神圣"></a>3.2 this.parse 到底为何方神圣</h5><p>看到下方代码，提取出我们需要的关键所在,  显然当我们第一次 解析传入的模板时是不可能存在 tokens的，那么parseTemplate又是什么呢？带着这个疑问，我们继续探索</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Writer.prototype.parse = <span class="function"><span class="keyword">function</span> <span class="title">parse</span> (<span class="params">template, tags</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//var cache = this.templateCache;</span></span><br><span class="line">    <span class="comment">//var cacheKey = template + &#x27;:&#x27; + (tags || mustache.tags).join(&#x27;:&#x27;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//var isCacheEnabled = typeof cache !== &#x27;undefined&#x27;;</span></span><br><span class="line">    <span class="keyword">var</span> tokens = isCacheEnabled ? cache.get(cacheKey) : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tokens == <span class="literal">undefined</span>) &#123; <span class="comment">// 保存解析 token</span></span><br><span class="line">      tokens = parseTemplate(template, tags);   <span class="comment">// parseTemplate</span></span><br><span class="line">      isCacheEnabled &amp;&amp; cache.set(cacheKey, tokens);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>但是当我们找到了它，我们发现这居然是一个100+行的代码块显然对于我这种源码阅历不充分的小萌新不是很友好，这个时候我们需要划分一下结构，我们看到它主要的组成应该是下面的一个结构，阅读 stripSpace函数，compileTags我们可以发现它们分别是用于去除空格，和tag解析的，默认情况 我们使用 mustache.tags = [ ‘, ‘ ],所以这里我们将注意点放在 scanner ，squashTokens，nestTokens上</p>
<p>-parseTemplate</p>
<p>​    -stripSpace</p>
<p>​    -compileTags</p>
<p>​    -scanner</p>
<p>​    -while循环</p>
<p>​    -squashTokens</p>
<p>​    -nestTokens</p>
<h6 id="3-2-1-Scanner解读"><a href="#3-2-1-Scanner解读" class="headerlink" title="3.2.1 Scanner解读"></a>3.2.1 Scanner解读</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次调用parseTemplate都会有  var scanenr = new Scanner,因此我们需要对Scanner一探究竟</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A simple string scanner that is used by the template parser to find</span></span><br><span class="line"><span class="comment">   * tokens in template strings.</span></span><br><span class="line"><span class="comment">   * 阅读描述我们发现scanner的作用是在于将传入字符串转换为 tokens arr，接着我们去看它的具体实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scanner</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.string = string; <span class="comment">//需要解析的所有字符串</span></span><br><span class="line">  <span class="built_in">this</span>.tail = string; <span class="comment">//需要继续解析的字符串</span></span><br><span class="line">  <span class="built_in">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns `true` if the tail is empty (end of string).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 判断扫描是否结束</span></span><br><span class="line">Scanner.prototype.eos = <span class="function"><span class="keyword">function</span> <span class="title">eos</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.tail === <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Tries to match the given regular expression at the current position.</span></span><br><span class="line"><span class="comment">   * Returns the matched text if it can match, the empty string otherwise.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//用正则匹配扫描部分</span></span><br><span class="line"><span class="comment">// 用于跳过 &#123;&#123;&#125;&#125; &lt;% ... 等边界符号</span></span><br><span class="line">  Scanner.prototype.scan = <span class="function"><span class="keyword">function</span> <span class="title">scan</span> (<span class="params">re</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> match = <span class="built_in">this</span>.tail.match(re);</span><br><span class="line">    <span class="keyword">if</span> (!match || match.index !== <span class="number">0</span>) <span class="comment">//字符串index 0-n 与re匹配</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> string = match[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">this</span>.tail = <span class="built_in">this</span>.tail.substring(string.length); <span class="comment">// 跳过扫描部分</span></span><br><span class="line">    <span class="built_in">this</span>.pos += string.length;  <span class="comment">// 移动指针</span></span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Skips all text until the given regular expression can be matched. Returns</span></span><br><span class="line"><span class="comment">   * the skipped string, which is the entire tail if no match can be made.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">例如  &quot;1243243453453&#123;&#123;name&#125;&#125;&quot;</span></span><br><span class="line"><span class="comment">输入正则匹配 &#123;&#123;</span></span><br><span class="line"><span class="comment">那么我们需要返回1243243453453</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  Scanner.prototype.scanUntil = <span class="function"><span class="keyword">function</span> <span class="title">scanUntil</span> (<span class="params">re</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="built_in">this</span>.tail.search(re), match;</span><br><span class="line">    <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">      <span class="keyword">case</span> -<span class="number">1</span>:	<span class="comment">//整个字符串都不存在 匹配正则的字符 / 字符串</span></span><br><span class="line">        match = <span class="built_in">this</span>.tail;</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        match = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: <span class="comment">//找到匹配位置</span></span><br><span class="line">        match = <span class="built_in">this</span>.tail.substring(<span class="number">0</span>, index);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="built_in">this</span>.tail.substring(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.pos += match.length;</span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>ok， 完成了Scanner的阅读我获取到几个有用信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Scanner.prototype.scanUntil 会在遇到匹配标签时停下并返回前面那段字符串</span><br><span class="line">Scanner.prototype.scan	会在遇到匹配标签时停下，跳过并且返回该匹配项</span><br></pre></td></tr></table></figure>
<p>话不多说以图示意</p>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/mustache-learn/m2.png"></p>
<p>好的接下来让我们阅读一下，这个while循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">value = scanner.scanUntil(openingTagRe)</span><br><span class="line"> <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, valueLength = value.length; i &lt; valueLength; ++i) &#123;</span><br><span class="line">        chr = value.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (isWhitespace(chr)) &#123;<span class="comment">//空白符</span></span><br><span class="line">          spaces.push(tokens.length);</span><br><span class="line">          indentation += chr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          nonSpace = <span class="literal">true</span>;</span><br><span class="line">          lineHasNonSpace = <span class="literal">true</span>;</span><br><span class="line">          indentation += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tokens.push([ <span class="string">&#x27;text&#x27;</span>, chr, start, start + <span class="number">1</span> ]); <span class="comment">//text用于标识该token的类型，区别view的需要</span></span><br><span class="line">        start += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Check for whitespace on the current line.</span></span><br><span class="line">        <span class="comment">// 有换行符的操作 ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*首先我们需要明确,在 &quot;&#123;&#123;&quot; 头标签之前停下的返回的match是不需要使用我们的view进行填充的，因此可以直接向tokens数组中push</span></span><br><span class="line"><span class="comment">这里需要这样一个逐个字符操作的原因是为了适配更多的场景比如&lt;tag class=&quot;xx xx&quot;&gt;，进行字符拆解作用可以便于之后stripSpace，</span></span><br><span class="line"><span class="comment">squashTokens这些函数的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!scanner.scan(openingTagRe)) <span class="comment">// 跳过前标签 例如：&#123;&#123;,不存在前标签则退出while循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"> hasTag = <span class="literal">true</span>;</span><br><span class="line"> <span class="comment">// Get the tag type.</span></span><br><span class="line"> type = scanner.scan(tagRe) || <span class="string">&#x27;name&#x27;</span>; <span class="comment">//获取类似 &#123;&#123;#name&#125;&#125; 中的 #</span></span><br><span class="line"> scanner.scan(whiteRe); <span class="comment">// 跳过空白符</span></span><br><span class="line"> <span class="comment">// ......</span></span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">  value = scanner.scanUntil(equalsRe);</span><br><span class="line">  scanner.scan(equalsRe);</span><br><span class="line">  scanner.scanUntil(closingTagRe);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;&#123;&#x27;</span>) &#123; </span><br><span class="line">  value = scanner.scanUntil(closingCurlyRe);</span><br><span class="line">  scanner.scan(curlyRe);</span><br><span class="line">  scanner.scanUntil(closingTagRe); </span><br><span class="line">  type = <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//默认的 &#123;&#123; 关注部分</span></span><br><span class="line">  value = scanner.scanUntil(closingTagRe); <span class="comment">// 返回 &#123;&#123;#  name&#125;&#125;中的name部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;&gt;&#x27;</span>) &#123;</span><br><span class="line">    token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">token = [ type, value, start, scanner.pos ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们需要确认一点 text 的 token 会被拆分为单个字符，但是 其他类型 如 name类型 #类型 都不会被被拆分为单个字符</p>
<h6 id="3-2-2-squashTokens解读"><a href="#3-2-2-squashTokens解读" class="headerlink" title="3.2.2 squashTokens解读"></a>3.2.2 squashTokens解读</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//squash Tokens 字面理解对tokens进行压缩，前面我们也提到text 会被拆分那么这个时候我们需要重新在进行组装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">squashTokens</span> (<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> squashedTokens = [];</span><br><span class="line">    <span class="keyword">var</span> token, lastToken; <span class="comment">//lastToken 用于拼接，引用的思想</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, numTokens = tokens.length; i &lt; numTokens; ++i) &#123;</span><br><span class="line">      token = tokens[i];</span><br><span class="line">      <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="keyword">if</span> (token[<span class="number">0</span>] === <span class="string">&#x27;text&#x27;</span> &amp;&amp; lastToken &amp;&amp; lastToken[<span class="number">0</span>] === <span class="string">&#x27;text&#x27;</span>) &#123; <span class="comment">//token 此处为合并的关键句</span></span><br><span class="line">          lastToken[<span class="number">1</span>] += token[<span class="number">1</span>];</span><br><span class="line">          lastToken[<span class="number">3</span>] = token[<span class="number">3</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          squashedTokens.push(token);</span><br><span class="line">          lastToken = token; <span class="comment">//保持对当前 token 的引用</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> squashedTokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-2-3-nestTokens解读：这里也是关键的一步"><a href="#3-2-3-nestTokens解读：这里也是关键的一步" class="headerlink" title="3.2.3 nestTokens解读：这里也是关键的一步"></a>3.2.3 nestTokens解读：这里也是关键的一步</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nestTokens 字面理解 嵌套 tokens，在进行压缩后，使tokens变成一种token树的结构，为后面token tree --&gt; htmlStr 做准备</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nestTokens</span> (<span class="params">tokens</span>) </span>&#123;<span class="comment">//整体 使用 栈数据结构的思想 + 引用保存</span></span><br><span class="line">    <span class="keyword">var</span> nestedTokens = [];</span><br><span class="line">    <span class="keyword">var</span> collector = nestedTokens;</span><br><span class="line">    <span class="keyword">var</span> sections = [];</span><br><span class="line">    <span class="keyword">var</span> token, section;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, numTokens = tokens.length; i &lt; numTokens; ++i) &#123;</span><br><span class="line">      token = tokens[i];</span><br><span class="line">      <span class="keyword">switch</span> (token[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">          collector.push(token);</span><br><span class="line">          sections.push(token); <span class="comment">// 压栈</span></span><br><span class="line">          collector = token[<span class="number">4</span>] = []; <span class="comment">// 更换collector的引用,token[4] 使为引用的token的4号索引位置创建一个空数组</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">          section = sections.pop(); <span class="comment">// 弹栈</span></span><br><span class="line">          section[<span class="number">5</span>] = token[<span class="number">2</span>];</span><br><span class="line">          collector = sections.length &gt; <span class="number">0</span> ? sections[sections.length - <span class="number">1</span>][<span class="number">4</span>] : nestedTokens;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          collector.push(token);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nestedTokens;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们需要获得一个如下结构的 token tree</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tokenTree = [</span><br><span class="line">    [<span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;property&#x27;</span>, <span class="attr">childTree</span>: [</span><br><span class="line">     	[<span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">    	...</span><br><span class="line">    ]],</span><br><span class="line">    [<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;property&#x27;</span>],</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/mustache-learn/m3.png"></p>
<p>到此我们就完成了 template string -&gt; token tree 的解析 就是 render必要操作的第一步</p>
<h5 id="3-3-context-与-view"><a href="#3-3-context-与-view" class="headerlink" title="3.3 context 与 view"></a>3.3 context 与 view</h5><p>对于context，我们认为我们需要知道的是它与view 的关系</p>
<h6 id="3-3-1首先是Context的属性"><a href="#3-3-1首先是Context的属性" class="headerlink" title="3.3.1首先是Context的属性"></a>3.3.1首先是Context的属性</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Context</span> (<span class="params">view, parentContext</span>) </span>&#123; <span class="comment">// Context 对应 view的管理 --&gt; 也就是 data</span></span><br><span class="line">    <span class="built_in">this</span>.view = view;</span><br><span class="line">    <span class="built_in">this</span>.cache = &#123; <span class="string">&#x27;.&#x27;</span>: <span class="built_in">this</span>.view &#125;; <span class="comment">//默认 增加 &#123; &#x27;.&#x27; : this.view &#125;</span></span><br><span class="line">    <span class="built_in">this</span>.parent = parentContext; <span class="comment">//通过 this.parent 引用 将整个 view 联系起来</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-3-2-其次是其中的一个关键函数-lookup"><a href="#3-3-2-其次是其中的一个关键函数-lookup" class="headerlink" title="3.3.2 其次是其中的一个关键函数 lookup"></a>3.3.2 其次是其中的一个关键函数 lookup</h6><p>这个函数也是有一定的篇幅，但是我们只需要我们所关注的</p>
<p>1.首先我们的得确定我们在应用中会出先  的形式</p>
<p>2.其次mustache库中提供了一种下面的支持来更好的遍历 [1,2,3] 这种形式的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;#list&#125;&#125;</span><br><span class="line">	&#123;&#123;.&#125;&#125;</span><br><span class="line">&#123;&#123;/list&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>3.我们会先使用当前 context的 属性值，但是当前不存在的时候我们不应该立即undefined，而是向上查找 this.parent</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> view = &#123;</span><br><span class="line">    list: [&#123;<span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>&#125;],</span><br><span class="line">    apps: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#123;&#123;#list&#125;&#125;</span><br><span class="line">	&lt;h1&gt;</span><br><span class="line">    	&#123;&#123;#apps&#125;&#125;</span><br><span class="line">        	&lt;strong&gt;&#123;&#123;name&#125;&#125;&lt;/strong&gt; </span><br><span class="line">        &#123;&#123;/apps&#125;&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">&#123;&#123;/list&#125;&#125;</span><br><span class="line"><span class="comment">//输出结果 ===&gt;</span></span><br><span class="line">&lt;h1&gt;</span><br><span class="line">    &lt;strong&gt;xxx&lt;/strong&gt; </span><br><span class="line"> 	&lt;strong&gt;xxx&lt;/strong&gt; </span><br><span class="line">    &lt;strong&gt;xxx&lt;/strong&gt; </span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/mustache-learn/m4.png"></p>
<h5 id="3-4-最后的渲染-this-renderTokens"><a href="#3-4-最后的渲染-this-renderTokens" class="headerlink" title="3.4 最后的渲染 this.renderTokens"></a>3.4 最后的渲染 this.renderTokens</h5><h6 id="3-4-1-从简单的render-函数看起"><a href="#3-4-1-从简单的render-函数看起" class="headerlink" title="3.4.1 从简单的render 函数看起"></a>3.4.1 从简单的render 函数看起</h6><p>​        在通过对this.renderTokens函数的寻找过程中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Writer.prototype.renderTokens = <span class="function"><span class="keyword">function</span> <span class="title">renderTokens</span> (<span class="params">tokens, context, partials, originalTemplate, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> token, symbol, value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, numTokens = tokens.length; i &lt; numTokens; ++i) &#123;</span><br><span class="line">      value = <span class="literal">undefined</span>;</span><br><span class="line">      token = tokens[i];</span><br><span class="line">      symbol = token[<span class="number">0</span>]; <span class="comment">//获取token的 type</span></span><br><span class="line">      <span class="keyword">if</span> (symbol === <span class="string">&#x27;#&#x27;</span>) value = <span class="built_in">this</span>.renderSection(token, context, partials, originalTemplate, config);</span><br><span class="line">      <span class="comment">//... 中间这部分的判断并非我的关注点</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (symbol === <span class="string">&#x27;name&#x27;</span>) value = <span class="built_in">this</span>.escapedValue(token, context, config);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (symbol === <span class="string">&#x27;text&#x27;</span>) value = <span class="built_in">this</span>.rawValue(token);</span><br><span class="line">      <span class="keyword">if</span> (value !== <span class="literal">undefined</span>)</span><br><span class="line">        buffer += value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	其中 this.renderSection，this.escapedValue，this.rawValue(token); 应该是大同小异, 对text需要进行转义防止对页面插入一些脚本</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h6 id="3-4-2-this-renderSection"><a href="#3-4-2-this-renderSection" class="headerlink" title="3.4.2 this.renderSection"></a>3.4.2 this.renderSection</h6><p>​    既然 this.renderSection，this.escapedValue，this.rawValue(token); 应该是大同小异，那么我们就取其中最为重要的  ‘this.renderSection’做文章,</p>
<p>​    但是终究还是要用this.escapedValue，this.rawValue进行模板的填充</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配合上述的 this.renderTokens 形成递归,可以遍历整个token tree</span></span><br><span class="line">Writer.prototype.renderSection = <span class="function"><span class="keyword">function</span> <span class="title">renderSection</span> (<span class="params">token, context, partials, originalTemplate, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> value = context.lookup(token[<span class="number">1</span>]); <span class="comment">// 取出view中 #property 对应的数据，用于判断</span></span><br><span class="line">    <span class="comment">// This function is used to render an arbitrary template</span></span><br><span class="line">    <span class="comment">// in the current context by higher-order sections.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subRender</span> (<span class="params">template</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.render(template, context, partials, config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 判断对应value 的 type 并且 创建一个新的 context</span></span><br><span class="line">    <span class="keyword">if</span> (isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, valueLength = value.length; j &lt; valueLength; ++j) &#123;</span><br><span class="line">        buffer += <span class="built_in">this</span>.renderTokens(token[<span class="number">4</span>], context.push(value[j]), partials, originalTemplate, config);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      buffer += <span class="built_in">this</span>.renderTokens(token[<span class="number">4</span>], context.push(value), partials, originalTemplate, config);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(value)) &#123;</span><br><span class="line">      <span class="comment">// 错误处理</span></span><br><span class="line">      value = value.call(context.view, originalTemplate.slice(token[<span class="number">3</span>], token[<span class="number">5</span>]), subRender);</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">        buffer += value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffer += <span class="built_in">this</span>.renderTokens(token[<span class="number">4</span>], context, partials, originalTemplate, config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>最终this.renderTokens 返回的 buffer就是我们调用 mustache.render(template., view)的结果</p>
<h4 id="4-结束总结"><a href="#4-结束总结" class="headerlink" title="4. 结束总结"></a>4. 结束总结</h4><p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/mustache-learn/m5.png"></p>
<h4 id="第一次分享个人的源码理解可能有许多需要努力的地方，如果你看到这里，那么感谢你的浏览，如有错误希望指出"><a href="#第一次分享个人的源码理解可能有许多需要努力的地方，如果你看到这里，那么感谢你的浏览，如有错误希望指出" class="headerlink" title="第一次分享个人的源码理解可能有许多需要努力的地方，如果你看到这里，那么感谢你的浏览，如有错误希望指出"></a>第一次分享个人的源码理解可能有许多需要努力的地方，如果你看到这里，那么感谢你的浏览，如有错误希望指出</h4><p>下面是我学习mustache源码的方式</p>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/mustache-learn/m6.png"></p>
<p>如有需要以下链接自取：</p>
<p><a href="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/mustache-learn/mustache%E6%8B%86%E5%9D%97%E5%AD%A6%E4%B9%A0.zip">https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/mustache-learn/mustache%E6%8B%86%E5%9D%97%E5%AD%A6%E4%B9%A0.zip</a></p>
<p>我是 加油 希望成为你的朋友</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>起步-snabbdom</title>
    <url>/2021/02/01/hello-snabbdom/</url>
    <content><![CDATA[<h2 id="听说vue的virtualDOM部分的设计有借鉴snabbdom-正好现在水平也不够去阅读vue的源码，正好用snabbdom来联系思维与阅读能力，为未来我阅读vue打下一点小台阶，话不多说开整"><a href="#听说vue的virtualDOM部分的设计有借鉴snabbdom-正好现在水平也不够去阅读vue的源码，正好用snabbdom来联系思维与阅读能力，为未来我阅读vue打下一点小台阶，话不多说开整" class="headerlink" title="听说vue的virtualDOM部分的设计有借鉴snabbdom?正好现在水平也不够去阅读vue的源码，正好用snabbdom来联系思维与阅读能力，为未来我阅读vue打下一点小台阶，话不多说开整"></a>听说vue的virtualDOM部分的设计有借鉴snabbdom?正好现在水平也不够去阅读vue的源码，正好用snabbdom来联系思维与阅读能力，为未来我阅读vue打下一点小台阶，话不多说开整</h2><h4 id="一-全局走向分析"><a href="#一-全局走向分析" class="headerlink" title="一. 全局走向分析"></a>一. 全局走向分析</h4><h5 id="1-首先打开npm下载到本地的snabbdom包，分析文件目录"><a href="#1-首先打开npm下载到本地的snabbdom包，分析文件目录" class="headerlink" title="1.首先打开npm下载到本地的snabbdom包，分析文件目录"></a>1.首先打开npm下载到本地的snabbdom包，分析文件目录</h5><p>-src</p>
<p>​    -package</p>
<p>​        -h.ts                                        -提供了h 函数 用于生成vnode</p>
<p>​        -hooks.ts                                </p>
<p>​        -htmldomapi.ts                     -提供了一些dom操作的封装</p>
<p>​        -init.ts                                     -提供了init 函数 组装function module 并返回一个patch,用于将vnode 上树 domTree，同时包含了diff算法</p>
<p>​        -is.ts                                        -提供了 数组 和 原始值判断函数</p>
<p>​        -jsx.ts                                      </p>
<p>​        -jsx-global.ts                        </p>
<p>​        -thunk.ts                                </p>
<p>​        -tovnode.ts</p>
<p>​        -vnode.ts                                -ts类型的管理，定义了类型的结构</p>
<p>以上未标注部分均不在本次阅读的范围内，本次阅读主要针对 diff算法 与 virtualDOM的工作原理</p>
<h5 id="2-简单说明virtualDOM的工作原理（Vnode：虚拟node-Node：DOM树上的node）"><a href="#2-简单说明virtualDOM的工作原理（Vnode：虚拟node-Node：DOM树上的node）" class="headerlink" title="2.简单说明virtualDOM的工作原理（Vnode：虚拟node, Node：DOM树上的node）"></a>2.简单说明virtualDOM的工作原理（Vnode：虚拟node, Node：DOM树上的node）</h5><ul>
<li>为减少DOM操作的成本，提供了经典的diff算法，精确的比较出差异，并进行DOM更新</li>
<li>1.减少成本，但是将Vnode -&gt;  Node 上树仍然需要dom操作</li>
<li>2.本质是Vnode 与 Vnode 的比较，而并非 Vnode 与 Node的比较</li>
</ul>
<h5 id="3-snabbdom案例分析大局"><a href="#3-snabbdom案例分析大局" class="headerlink" title="3.snabbdom案例分析大局"></a>3.snabbdom案例分析大局</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> patch = init([ <span class="comment">// Init patch function with chosen modules</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">])</span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> vnode = h(<span class="string">&#x27;div#container.two.classes&#x27;</span>, &#123; <span class="attr">props</span>: &#123;&#125; ... &#125;, [</span><br><span class="line">    <span class="comment">//vnode children</span></span><br><span class="line">])</span><br><span class="line">patch(container, vnode) <span class="comment">//上树</span></span><br><span class="line"><span class="keyword">var</span> newVnode = h(<span class="string">&#x27;div#container.two.classes&#x27;</span>, &#123; <span class="attr">props</span>: &#123;&#125; ...  &#125;, [</span><br><span class="line">  <span class="comment">//vnode children</span></span><br><span class="line">])</span><br><span class="line">patch(vnode, newVnode)</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/snabbdom/1.png"></p>
<h4 id="二-进入正题"><a href="#二-进入正题" class="headerlink" title="二.进入正题"></a>二.进入正题</h4><p>通过上面的例子我们就已经可以发现了，我们的关注点应该为 h 函数 和 另一个 patch 函数，那么就让我们继续往下走</p>
<h5 id="1-分析-h-函数"><a href="#1-分析-h-函数" class="headerlink" title="1.分析 h 函数"></a>1.分析 h 函数</h5><p>h.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span> (<span class="params">sel: <span class="built_in">any</span>, b?: <span class="built_in">any</span>, c?: <span class="built_in">any</span></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data: VNodeData = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> children: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">var</span> text: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">var</span> i: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">if</span> (c !== <span class="literal">undefined</span>) &#123;<span class="comment">// 三个参数的情况</span></span><br><span class="line">    <span class="keyword">if</span> (b !== <span class="literal">null</span>) &#123;</span><br><span class="line">      data = b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is.array(c)) &#123;</span><br><span class="line">      children = c</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(c)) &#123;</span><br><span class="line">      text = c</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &amp;&amp; c.sel) &#123; <span class="comment">//只有一个对象,进行包装</span></span><br><span class="line">      children = [c]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b !== <span class="literal">undefined</span> &amp;&amp; b !== <span class="literal">null</span>) &#123; <span class="comment">// 两个参数的情况</span></span><br><span class="line">    <span class="keyword">if</span> (is.array(b)) &#123;</span><br><span class="line">      children = b</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(b)) &#123;</span><br><span class="line">      text = b</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &amp;&amp; b.sel) &#123;</span><br><span class="line">      children = [b]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; data = b &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (children !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (is.primitive(children[i])) children[i] = vnode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, children[i], <span class="literal">undefined</span>)<span class="comment">//child为string,number</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    sel[<span class="number">0</span>] === <span class="string">&#x27;s&#x27;</span> &amp;&amp; sel[<span class="number">1</span>] === <span class="string">&#x27;v&#x27;</span> &amp;&amp; sel[<span class="number">2</span>] === <span class="string">&#x27;g&#x27;</span> &amp;&amp;</span><br><span class="line">    (sel.length === <span class="number">3</span> || sel[<span class="number">3</span>] === <span class="string">&#x27;.&#x27;</span> || sel[<span class="number">3</span>] === <span class="string">&#x27;#&#x27;</span>) <span class="comment">//svg svg. svg#</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    addNS(data, children, sel)<span class="comment">//针对svg标签的操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vnode(sel, data, children, text, <span class="literal">undefined</span>) <span class="comment">//返回的vnode</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>vnode.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">vnode</span> (<span class="params">sel: <span class="built_in">string</span> | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//...</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> &#123; sel, data, children, text, elm, key &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>


<p>从上面的代码我们可以发现h 函数的主要作用 就是  生成  vnode函数所返会的结构 { sel, data, children, text, elm, key }</p>
<h5 id="2-patch-函数"><a href="#2-patch-函数" class="headerlink" title="2.patch 函数"></a>2.patch 函数</h5><p>因为patch才是整个精细比较的主体所以难度比 h 包要高一点,首先patch由 init 返回，我们就需要去锁定init的返回值</p>
<p>init.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i: <span class="built_in">number</span>, <span class="attr">elm</span>: Node, <span class="attr">parent</span>: Node</span><br><span class="line">    <span class="comment">//const insertedVnodeQueue: VNodeQueue = []</span></span><br><span class="line">    <span class="comment">//for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i]()</span></span><br><span class="line">    <span class="keyword">if</span> (!isVnode(oldVnode)) &#123;<span class="comment">//第一个参数不是virtualDOM,如：案例的container</span></span><br><span class="line">      oldVnode = emptyNodeAt(oldVnode) <span class="comment">//调用emptyNodeAt将其转为vnode</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">      patchVnode(oldVnode, vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elm = oldVnode.elm!</span><br><span class="line">      parent = api.parentNode(elm) <span class="keyword">as</span> Node</span><br><span class="line">      createElm(vnode, insertedVnodeQueue)	<span class="comment">//新增Node</span></span><br><span class="line">      <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm))</span><br><span class="line">        removeVnodes(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)	<span class="comment">//删除OldNode</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insertedVnodeQueue.length; ++i) &#123;</span><br><span class="line">      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.post.length; ++i) cbs.post[i]()</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emptyNodeAt</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emptyNodeAt</span> (<span class="params">elm: Element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = elm.id ? <span class="string">&#x27;#&#x27;</span> + elm.id : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> c = elm.className ? <span class="string">&#x27;.&#x27;</span> + elm.className.split(<span class="string">&#x27; &#x27;</span>).join(<span class="string">&#x27;.&#x27;</span>) : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> vnode(api.tagName(elm).toLowerCase() + id + c, &#123;&#125;, [], <span class="literal">undefined</span>, elm)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>初步流程图出炉</p>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/snabbdom/2.png"></p>
<p>到目前为止所有的判断都是简单判断 ,  新增和删除都已经使用了dom操作，而这里也说明了调用patchVnode更新的前提是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">vnode1: VNode, vnode2: VNode</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vnode1.key === vnode2.key &amp;&amp; vnode1.sel === vnode2.sel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不对createElm 和 removeVnodes进行分析了，createElm 是一个运用了递归能够将所有children从vnode -&gt; node 的函数，而removeVnodes则是可以大批量从domTree上删除dom节点的操作其中createElm包含了较多的判断可以严谨的生成TextNode，TagNode，CommentNode节点</p>
<h5 id="3-进入patchVnode"><a href="#3-进入patchVnode" class="headerlink" title="3.进入patchVnode"></a>3.进入patchVnode</h5><p>在patchVnode函数中包含了updateChildren,这个操作中就包含了核心的diff算法</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    const hook = vnode.data?.hook</span></span><br><span class="line"><span class="comment">    hook?.prepatch?.(oldVnode, vnode)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm!</span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children <span class="keyword">as</span> VNode[]</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children <span class="keyword">as</span> VNode[]</span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (vnode.data !== undefined) &#123;</span></span><br><span class="line"><span class="comment">      for (let i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span></span><br><span class="line"><span class="comment">      vnode.data.hook?.update?.(oldVnode, vnode)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) api.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        api.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      api.setTextContent(elm, vnode.text!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hook?.postpatch?.(oldVnode, vnode)</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>去除了一些生命周期的代码，我们可以大致得出以下流程</p>
<p>这里作者有一个非常巧妙的方法将第一步判断节点划分为两个路线</p>
<p><strong>这个方式存在于h包中,在生成vnode时候每一个vnode 的children属性和text属性不可能同时存在有效值</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (is.array(c)) &#123;</span><br><span class="line">  children = c</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(c)) &#123;</span><br><span class="line">  text = c</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &amp;&amp; c.sel) &#123; <span class="comment">//只有一个对象,进行包装</span></span><br><span class="line">  children = [c]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/snabbdom/3.png"></p>
<h5 id="4-有趣的diff"><a href="#4-有趣的diff" class="headerlink" title="4.有趣的diff"></a>4.有趣的diff</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm: Node,</span></span></span><br><span class="line"><span class="function"><span class="params">    oldCh: VNode[],</span></span></span><br><span class="line"><span class="function"><span class="params">    newCh: VNode[],</span></span></span><br><span class="line"><span class="function"><span class="params">    insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>, oldEndIdx = oldCh.length - <span class="number">1</span>, oldStartVnode = oldCh[<span class="number">0</span>], oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span>, newEndIdx = newCh.length - <span class="number">1</span>, newStartVnode = newCh[<span class="number">0</span>], newEndVnode = newCh[newEndIdx]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx: KeyToIndexMap | <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">let</span> idxInOld: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">let</span> elmToMove: VNode</span><br><span class="line">    <span class="keyword">let</span> before: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode might have been moved left</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        api.insertBefore(parentElm, oldStartVnode.elm!, api.nextSibling(oldEndVnode.elm!))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123; <span class="comment">//以下为map相关</span></span><br><span class="line">          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        &#125;</span><br><span class="line">        idxInOld = oldKeyToIdx[newStartVnode.key <span class="keyword">as</span> <span class="built_in">string</span>]</span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">////正在对比的节点不存在则是新节点 New element</span></span><br><span class="line">          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm!)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          elmToMove = oldCh[idxInOld]<span class="comment">//老的一个节点</span></span><br><span class="line">          <span class="keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;<span class="comment">// key 相同但是 sel 变了</span></span><br><span class="line">            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm!)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span> <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123;<span class="comment">//一整个while循环走下来，两个列表中有一个列表有剩余</span></span><br><span class="line">      <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<span class="comment">// 情况一 newCh 有剩余</span></span><br><span class="line">        before = newCh[newEndIdx + <span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)<span class="comment">// before为null 往末尾插入</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 情况一 oldCh 有剩余</span></span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/snabbdom/4.png"></p>
<p>分析得出以上结论，我们需要四个指针</p>
<p>四种不同的判断情况</p>
<h6 id="1-sameVnode-oldStartVnode-newStartVnode"><a href="#1-sameVnode-oldStartVnode-newStartVnode" class="headerlink" title="1. sameVnode(oldStartVnode, newStartVnode)"></a>1. sameVnode(oldStartVnode, newStartVnode)</h6><p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/snabbdom/5.png"></p>
<h6 id="2-sameVnode-oldEndVnode-newEndVnode"><a href="#2-sameVnode-oldEndVnode-newEndVnode" class="headerlink" title="2.sameVnode(oldEndVnode, newEndVnode)"></a>2.sameVnode(oldEndVnode, newEndVnode)</h6><p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/snabbdom/6.png"></p>
<h6 id="3-sameVnode-oldStartVnode-newEndVnode"><a href="#3-sameVnode-oldStartVnode-newEndVnode" class="headerlink" title="3.sameVnode(oldStartVnode, newEndVnode)"></a>3.sameVnode(oldStartVnode, newEndVnode)</h6><p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/snabbdom/7.png"></p>
<h6 id="4-sameVnode-oldStartVnode-newEndVnode"><a href="#4-sameVnode-oldStartVnode-newEndVnode" class="headerlink" title="4.sameVnode(oldStartVnode, newEndVnode)"></a>4.sameVnode(oldStartVnode, newEndVnode)</h6><p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/snabbdom/8.png"></p>
<h6 id="5-map的方式：该方式基于上述四种情形均不存在命中时，使用oldChildren列表中的每一项的key形成一个map降低了时间复杂度"><a href="#5-map的方式：该方式基于上述四种情形均不存在命中时，使用oldChildren列表中的每一项的key形成一个map降低了时间复杂度" class="headerlink" title="5.map的方式：该方式基于上述四种情形均不存在命中时，使用oldChildren列表中的每一项的key形成一个map降低了时间复杂度"></a>5.map的方式：该方式基于上述四种情形均不存在命中时，使用oldChildren列表中的每一项的key形成一个map降低了时间复杂度</h6><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span> (<span class="params">children: VNode[], beginIdx: <span class="built_in">number</span>, endIdx: <span class="built_in">number</span></span>): <span class="title">KeyToIndexMap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map: KeyToIndexMap = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = children[i]?.key</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      map[key] = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map = &#123;</span></span><br><span class="line"><span class="comment">  key1: 1,</span></span><br><span class="line"><span class="comment">  key2: 2</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当判断newList[newStartIdx].key 存在于 map中则进行更新，否则会直接新建</p>
<h6 id="6-while循环结束判断两个children列表是否都已经将指针走完"><a href="#6-while循环结束判断两个children列表是否都已经将指针走完" class="headerlink" title="6.while循环结束判断两个children列表是否都已经将指针走完"></a>6.while循环结束判断两个children列表是否都已经将指针走完</h6><h3 id="阅读源码不是个容易的事尽管我只找了一部分需要内容进行阅读但是感觉还是有些困惑，例如updateChildren中的最前面的判空，造成左移的是那部分代码的作用，我在写完这篇文章后的想法是一些removeChild操作造成的但是也只是部分猜测，如果你想与我分享你的认识请联系我的微信，谢谢"><a href="#阅读源码不是个容易的事尽管我只找了一部分需要内容进行阅读但是感觉还是有些困惑，例如updateChildren中的最前面的判空，造成左移的是那部分代码的作用，我在写完这篇文章后的想法是一些removeChild操作造成的但是也只是部分猜测，如果你想与我分享你的认识请联系我的微信，谢谢" class="headerlink" title="阅读源码不是个容易的事尽管我只找了一部分需要内容进行阅读但是感觉还是有些困惑，例如updateChildren中的最前面的判空，造成左移的是那部分代码的作用，我在写完这篇文章后的想法是一些removeChild操作造成的但是也只是部分猜测，如果你想与我分享你的认识请联系我的微信，谢谢"></a>阅读源码不是个容易的事尽管我只找了一部分需要内容进行阅读但是感觉还是有些困惑，例如updateChildren中的最前面的判空，造成左移的是那部分代码的作用，我在写完这篇文章后的想法是一些removeChild操作造成的但是也只是部分猜测，如果你想与我分享你的认识请联系我的微信，谢谢</h3><h3 id="我是加油希望成为你的朋友"><a href="#我是加油希望成为你的朋友" class="headerlink" title="我是加油希望成为你的朋友"></a>我是加油希望成为你的朋友</h3>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2021/01/06/hello-world/</url>
    <content><![CDATA[<p>  仔细回想，从接触代码到现在也已经有一年多的时间了，回想去年9月带着满怀期待步入这所大学。当时天真的我认为选择了计算机专业我就能顺应时代趋势毕业后收货一份心满意足的工作，但是一切因为碰见了李sir而改变。随后我去要到他的联系方式，在他的启发下我收获甚多，同时也明白了这个行业的水深，之后的两个月我在李先生的提一下第一次搭建了hexo但是过程十分地艰辛，并且最后因为改动了某个配置，年少的我（代码年龄）将刚配置的blog整的乱七八糟，无力回天。时隔一年，我的技术已有精进，但是接触越多感觉自己就越渺小。重拾hexo，我决定记录我的代码人生。</p>
]]></content>
      <categories>
        <category>感言</category>
      </categories>
      <tags>
        <tag>起步</tag>
      </tags>
  </entry>
  <entry>
    <title>使用typescript进行react-i18next类型推导</title>
    <url>/2021/05/05/integrate-ts-reacti18n/</url>
    <content><![CDATA[<h4 id="在create-react-app-版本为4-0-3-使用typescript进行react-i18next类型推导"><a href="#在create-react-app-版本为4-0-3-使用typescript进行react-i18next类型推导" class="headerlink" title="在create-react-app 版本为4.0.3 使用typescript进行react-i18next类型推导"></a>在create-react-app 版本为4.0.3 使用typescript进行react-i18next类型推导</h4><p>首先按照<a href="https://react.i18next.com/latest/typescript">官方文档</a>选择一种适合当前项目的定义方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import the original type declarations</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;react-i18next&#x27;</span>;</span><br><span class="line"><span class="comment">// import all namespaces (for the default language, only)</span></span><br><span class="line"><span class="keyword">import</span> ns1 <span class="keyword">from</span> <span class="string">&#x27;locales/en/ns1.json&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ns2 <span class="keyword">from</span> <span class="string">&#x27;locales/en/ns2.json&#x27;</span>;</span><br><span class="line"></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;react-i18next&#x27;</span> &#123;</span><br><span class="line">  <span class="comment">// and extend them!</span></span><br><span class="line">  interface Resources &#123;</span><br><span class="line">    ns1: <span class="keyword">typeof</span> ns1;</span><br><span class="line">    ns2: <span class="keyword">typeof</span> ns2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果采用官方的第一种方法(上面的这种形式)需要定义正确的 <code>NS</code>, 因为 <code>useTransition</code>使用默认命名空间<code>transition</code></p>
<p>所以我们的操作应该是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> translation <span class="keyword">from</span> <span class="string">&#x27;../../public/locales/en/translation.json&#x27;</span></span><br><span class="line"><span class="keyword">import</span> common <span class="keyword">from</span> <span class="string">&#x27;../../public/locales/en/common.json&#x27;</span></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;react-i18next&#x27;</span> &#123;</span><br><span class="line">  interface Resources &#123;</span><br><span class="line">    translation: <span class="keyword">typeof</span> translation,</span><br><span class="line">    common: <span class="keyword">typeof</span> common</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我增加了一个common的命名空间</p>
<p>其次在<code>react-app-env.d.ts</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;..&#x2F;@types&#x2F;react-i18next&#x2F;index.d.ts&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>经过测试两种方式都是可行的</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>一文解决我的js prototype难题（原型链）</title>
    <url>/2021/09/17/js-prototype/</url>
    <content><![CDATA[<blockquote>
<p>​    有的时候学的越多越发现自己懂得越少，本来的我认为js基础部分应当是没什么问题了。但是当我好奇地使用tsc工具将ts代码转换成js后我知道我又该翻开那本红宝书了，而现在的我也不是曾经那个拿着一本书从头翻到尾，回头一想却不曾在脑中留下半点知识的痕迹。我抄起书本翻到对象相关的第八章，打开md记录下自己的对知识的理解。</p>
</blockquote>
<p>这篇文章的主要目的是帮助理解何为原型链，我们用它做什么，在此之前最好是确保自己对引用数据类型和值类型有一定理解。</p>
<h4 id="js对象"><a href="#js对象" class="headerlink" title="js对象"></a>js对象</h4><p><strong>使用new关键字获得</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure>
<p><strong>使用字面量</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="描述js的内部特性：-xxx"><a href="#描述js的内部特性：-xxx" class="headerlink" title="描述js的内部特性：[[ xxx ]]"></a>描述js的内部特性：[[ xxx ]]</h4><p><strong>数据属性</strong>：存在value与writable描述时为数据属性</p>
<ul>
<li>[[configurable]]：是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为访问器属性，如再次 defineProperty同一个属性</li>
<li>[[enumerable]]：属性、方法是否参与迭代</li>
<li>[[writable]]：值是否可更改</li>
<li>[[value]]：值</li>
</ul>
<p><strong>访问器属性</strong>：访问器属性不包含数据值。存在get与set时不应该存在value与writable描述符</p>
<ul>
<li>[[configurable]]：是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为访问器属性，如再次 defineProperty同一个属性，<strong>使用defineProperty定义时</strong>默认为<code>false</code></li>
<li>[[enumerable]]：属性、方法是否参与迭代</li>
<li>[[get]]：读取，所有的属性读取操作都会调用[[get]]?</li>
<li>[[set]]：写入</li>
</ul>
<h4 id="一些特殊的判断"><a href="#一些特殊的判断" class="headerlink" title="一些特殊的判断"></a>一些特殊的判断</h4><p>大部分都可以利用自己对于隐式转换、值类型与引用数据类型的理解解决判断的问题。但是仍然有一些几乎用不到的情况，如下：</p>
<p><strong>+0 与 -0的判断：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="es6前创建对象的模式"><a href="#es6前创建对象的模式" class="headerlink" title="es6前创建对象的模式"></a>es6前创建对象的模式</h4><p><strong>工厂模式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    obj.name = name</span><br><span class="line">    obj.age = age</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = Person(name, age)</span><br></pre></td></tr></table></figure>
<p><strong>构造函数式</strong>：如果构造函数返回非null对象，则返回该对象；否则，返回刚创建的新对象。</p>
<p>只有和<code>new</code>操作符连用才能被成为构造函数（更准确的表述应该是构造调用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(name,age)</span><br></pre></td></tr></table></figure>
<h4 id="原型模式：为什么需要原型模式？"><a href="#原型模式：为什么需要原型模式？" class="headerlink" title="原型模式：为什么需要原型模式？"></a><strong>原型模式：</strong>为什么需要原型模式？</h4><ul>
<li><p>使用构造函数式创建对象无论是对象中的属性还是方法都会重新创建一次，<strong>重新开辟一次内存空间</strong>，对于共享属性、方法是一种浪费</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.getName === p2.getName);	<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
<li><p>如何理解：在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自 Object。正常的原型链都会终止于 Object 的原型对象</p>
<p><strong>用js来理解js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//理解函数原型上的方法继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.construct = Person</span><br><span class="line"><span class="comment">//---- 这段代码可以递归调用一直延申到Object.prototype</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> <span class="built_in">Object</span>.prototype) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Object</span>.hasOwnProperty(Person.prototype, k))</span><br><span class="line">        Person.prototype[k] = <span class="built_in">Object</span>.prototype[k]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----</span></span><br><span class="line"><span class="comment">//理解__proto__表示的意义</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//通过[[prototype]]链找到另一个函数的prototype</span></span><br><span class="line">Person.prototype.__proto__ <span class="comment">// 沿原型链查找一次输</span></span><br><span class="line">Person.prototype.__proto__.__proto__ <span class="comment">// 沿原型链查找两次输出 null</span></span><br></pre></td></tr></table></figure>
<p><strong>附一张边学边画的简化图</strong></p>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/js/prototype/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%AE%80%E5%8D%95%E5%B1%95%E7%A4%BA1.png"></p>
</li>
</ul>
<p>不能只看书籍，梳理知识可以动手画图，并且敲码验证</p>
<p><strong>“盗用构造函数”</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="built_in">this</span>, ...arguments)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sub = <span class="keyword">new</span> Sub(<span class="string">&#x27;zgz&#x27;</span>) <span class="comment">//Sub &#123;name: &#x27;zgz&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line"> <span class="built_in">this</span>.name = name; </span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//prototype上的仅创建一次有点类似 ava的Static method</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123; </span><br><span class="line"> <span class="comment">// 继承属性，继承了盗用构造函数的优点使得name属性更加灵活</span></span><br><span class="line"> SuperType.call(<span class="built_in">this</span>, name); </span><br><span class="line"> <span class="built_in">this</span>.age = age; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a><strong>原型模式</strong></h4><p><code>Object.create</code>使用的模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;<span class="comment">// o 表示一个实例 </span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"> F.prototype = o; <span class="comment">//所有的F函数共享o上的属性</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> F();  <span class="comment">//保证了F实例的修改不对其他实例造成影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123; </span><br><span class="line"> <span class="keyword">let</span> clone = object(original); <span class="comment">// 原型模式的共享</span></span><br><span class="line"> clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="寄生式组合继承：集众多继承模式优点于一身"><a href="#寄生式组合继承：集众多继承模式优点于一身" class="headerlink" title="寄生式组合继承：集众多继承模式优点于一身"></a>寄生式组合继承：集众多继承模式优点于一身</h4><p>避免了 SubType.prototype 上不必要也用不到的属性，原型链仍然保持不变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">let</span> prototype = object(superType.prototype); <span class="comment">// 创建对象</span></span><br><span class="line"> prototype.constructor = subType; <span class="comment">// 增强对象 </span></span><br><span class="line"> subType.prototype = prototype; <span class="comment">// 赋值一个新的prototype</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="instance操作符"><a href="#instance操作符" class="headerlink" title="instance操作符"></a><strong>instance操作符</strong></h4><p>用于沿着原型链查找，那原理究竟是如何呢?</p>
<p><strong>用js来理解js</strong></p>
<p>首先排除通过prototype中的constructor标识判断的情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Q</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor = Q;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Q);      <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>实际上constructor只是一个简单的记号，那么instanceof的机制到底是怎么样的呢？我的猜想是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">instance, Target</span>) </span>&#123;<span class="comment">//instance = p1, Target = Person</span></span><br><span class="line">    <span class="keyword">const</span> Prototype = Taget.prototype</span><br><span class="line">    <span class="keyword">let</span> proto = instance.__proto__</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(proto === <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(proto === Prototype)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        proto = proto.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="属性读取操作"><a href="#属性读取操作" class="headerlink" title="属性读取操作"></a>属性读取操作</h4><p>首先会在当前的实例上进行读取，如果读取不到会沿着[[Prototype]]进行读取，如果在顶级的prototype上仍然读取不到返回undefined</p>
<h4 id="in操作符与Object-keys"><a href="#in操作符与Object-keys" class="headerlink" title="in操作符与Object.keys()"></a><code>in</code>操作符与Object.keys()</h4><p>in操作符会遍历[[Prototype]]链上的可以</p>
<h4 id="重写整个原型与更改部分原型"><a href="#重写整个原型与更改部分原型" class="headerlink" title="重写整个原型与更改部分原型"></a>重写整个原型与更改部分原型</h4><p><strong>更改部分原型</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)&#125;</span><br><span class="line">p1.say()  <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p><strong>重写整个原型</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person	<span class="comment">//此时绑定在p2上的prototype并没有say方法</span></span><br><span class="line">Person.prototype = &#123;	<span class="comment">//内存中重新开辟的一个prototype</span></span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">    <span class="title">say</span>(<span class="params"></span>) &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;hello p2&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">p2.say()  <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<h4 id="证实Person-prototype与实例的绑定"><a href="#证实Person-prototype与实例的绑定" class="headerlink" title="证实Person.prototype与实例的绑定"></a>证实Person.prototype与实例的绑定</h4><p>下面的例子也可以证实重写整个prototype，其实这部分就是对于引用数据类型的理解</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">//假设此时Person上的prototype为xxx01</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)&#125;</span><br><span class="line">p1.say()  <span class="comment">// hello</span></span><br><span class="line">Person.prototype = &#123; <span class="comment">//那么此时Person上的prototype为xxx02</span></span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">    <span class="title">say</span>(<span class="params"></span>) &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;hello p2&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">p2.say()  <span class="comment">//hello</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> Person</span><br><span class="line">p3.say()  <span class="comment">//hello p2</span></span><br></pre></td></tr></table></figure>


<h4 id="区别对象的类型"><a href="#区别对象的类型" class="headerlink" title="区别对象的类型"></a>区别对象的类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.constructor === ConstructFunction</span><br><span class="line">obj <span class="keyword">instanceof</span> ConstructFunction</span><br></pre></td></tr></table></figure>
<h4 id="我对于继承模式的看法"><a href="#我对于继承模式的看法" class="headerlink" title="我对于继承模式的看法"></a>我对于继承模式的看法</h4><p>知道多少继承模式的名字并不重要，重要的是看透js中重要的prototype相关的用，以及看穿一个继承模式的优缺点。这样才能在项目中使用准确的继承模式。</p>
<h4 id="es6-class语法糖"><a href="#es6-class语法糖" class="headerlink" title="es6 class语法糖"></a>es6 class语法糖</h4><p>class 主体中的construct函数与之前的“构造函数”功能相同</p>
<p>主体中的方法被添加在 class的prototype上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="comment">//我们所谓的构造函数</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;&#125; <span class="comment">//将被加到Person.prototype上的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不多说类了，我认为把[[Prototype]]吃透搞定class应当是轻而易举的</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会</title>
    <url>/2021/09/03/mysql-necessary/</url>
    <content><![CDATA[<blockquote>
<p>最近正在学习使用java开发web应用，我认为一个合格的后端开发者应该掌握基本的sql操作，因此写下此篇记录下学习sql基础时的一些小细节</p>
<p>入门书籍<strong>《mysql必知必会》</strong>，罗列了我们需要知道的基本知识的概念。</p>
<p>sql_script地址：<a href="https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip">https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip</a></p>
</blockquote>
<h4 id="数据库的简单概念"><a href="#数据库的简单概念" class="headerlink" title="数据库的简单概念"></a>数据库的简单概念</h4><ul>
<li>DBS（database system） ：数据库与数据库管理系统的总称</li>
<li>DB（database） ：数据存放的位置</li>
<li>DBMS（database manage system）：管理数据库的应用程序</li>
</ul>
<p>1.你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。</p>
<p>2.<code>MySQL</code>是一种DBMS，即它是一种数据库软件。</p>
<p>3.<code>SQL</code>是一种专门用来与数据库通信的语言。</p>
<p>4.只有数据库知道SELECT语句中哪些列是实际的 表列，哪些列是计算字段。从客户机（如应用程序）的角度来看，计算 字段的数据是以与其他列的数据相同的方式返回的</p>
<p>5.<code>聚集函数</code>（count、avg、max、min等）操作针对的想要信息的是汇总信息</p>
<h4 id="简单的操作注意点"><a href="#简单的操作注意点" class="headerlink" title="简单的操作注意点"></a>简单的操作注意点</h4><p>1.在处理SQL语句时，其中所有<code>空格都被忽略</code>。SQL 语句可以在一行上给出，也可以分成许多行。同时也<code>s忽略大小写</code></p>
<p>2.检索出来的第一行为行0而不是行1。因此，LIMIT 1, 1 将检索出第二行而不是第一行</p>
<p>3.where 过滤查询信息时，优先进行 AND 逻辑， 后进行 OR逻辑</p>
<p>4.IN操作符一般比OR操作符清单执行更快。 IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建 立WHERE子句。</p>
<p>5.<code>%</code> 代表搜索模式中给定位置的<strong>0个</strong>、1个或多个字符。</p>
<p>6.在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。</p>
<p>7.<code>regexp  &#39;str&#39;</code>  默认相当于 <code>like &#39;%str%&#39;</code></p>
<p>8.多数正则表达式实现使用单个反斜杠转义特殊字符， 以便能使用这些字符本身。但MySQL要求两个反斜杠（MySQL 自己解释一个，正则表达式库解释另一个</p>
<p>9.<code>GROUP BY</code>子句和<code>HAVING</code>子句是一对</p>
<p>10.<code>varchar</code>虽然是可变长的但仍需要增加最大长度</p>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p><strong>相关子查询</strong>：涉及外部查询的子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> customers.cust_name, customers.cust_state,</span><br><span class="line">		(</span><br><span class="line">            <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">            <span class="keyword">from</span> orders</span><br><span class="line">            <span class="keyword">where</span> orders.cust_id <span class="operator">=</span> customers.cust_id</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">from</span> customers</span><br></pre></td></tr></table></figure>
<p>多表联结</p>
<p>联结是利用SQL的SELECT能执行的最重要的操作，很好地理解联结 及其语法是学习SQL的一个极为重要的组成部分。</p>
<p>关系表的设计就是要保证把信息分解成多个表，一类数据 一个表。各表通过某些常用的值（即关系设计中的关系（relational））互 相关联。</p>
<p>外键为某个表中的一列，它包含另一个表 的主键值，定义了两个表之间的关系。</p>
<p>重要的是，要理解联结不是物理实体。换句 话说，它在实际的数据库表中不存在。联结由MySQL根据需 要建立，它存在于查询的执行当中。</p>
<p>在联结两个表时，你实际上做 的是将第一个表中的每一行与第二个表中的每一行配对。</p>
<p><strong>内部联结</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vendors.vend_name, products.prod_name,products.prod_price</span><br><span class="line"><span class="keyword">from</span> vendors <span class="keyword">inner</span> <span class="keyword">join</span> products</span><br><span class="line"><span class="keyword">on</span> vendors.vend_id <span class="operator">=</span> products.vend_id</span><br></pre></td></tr></table></figure>
<p>与下方表示相同</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vendors.vend_name, products.prod_name,products.prod_price</span><br><span class="line"><span class="keyword">from</span> vendors, products</span><br><span class="line"><span class="keyword">where</span> vendors.vend_id <span class="operator">=</span> products.vend_id</span><br></pre></td></tr></table></figure>
<p>MySQL在运行时关联指定的每个表以处理联结。 这种处理可能是非常耗费资源的，因此应该仔细，不要联结 不必要的表。联结的表越多，性能下降越厉害。</p>
<p>高级联结</p>
<p>**自联结 **</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> p1.prod_name</span><br><span class="line"><span class="keyword">from</span> products <span class="keyword">as</span> p1 <span class="keyword">inner</span> <span class="keyword">join</span> products <span class="keyword">as</span> p</span><br><span class="line"><span class="keyword">on</span> p.prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span></span><br><span class="line"><span class="keyword">and</span> p1.vend_id <span class="operator">=</span> p.vend_id</span><br></pre></td></tr></table></figure>
<p><strong>外联结</strong></p>
<p>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表</p>
<p>分组结果无法展示一对多关系，只能展示对汇总的关系</p>
<p>Union（组合查询）</p>
<p>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</p>
<p><strong>全文本搜索</strong></p>
<p>并非所有引擎都支持全文本搜索</p>
<p>两个最常使用的引擎为MyISAM和InnoDB， 前者支持全文本搜索，而后者不支持。</p>
<p>启用全文本搜索</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> productnotes(</span><br><span class="line">	note_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    note_text text <span class="keyword">null</span>,</span><br><span class="line">    ....,</span><br><span class="line">    <span class="keyword">primary</span> <span class="keyword">key</span>(note_id),</span><br><span class="line">    fulltext(note_text)</span><br><span class="line">) engine<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>
<p>正如所见，全文本搜索提供了简单LIKE搜索不能提供的功能。而且， 由于数据是索引的，全文本搜索还相当快。</p>
<p>如果数据检索(query)是最重要的（通常是这样），则你可以通过在 INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL 降低INSERT语句的优先级，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> low_priority <span class="keyword">into</span></span><br></pre></td></tr></table></figure>
<p><strong>insert into 性能提升</strong></p>
<p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来， 用逗号分隔。</p>
<p>提高INSERT的性能 此技术可以提高数据库处理的性能，因 为MySQL用单条INSERT语句处理多个插入比使用多条INSERT 语句快。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name (name) <span class="keyword">values</span> (<span class="string">&#x27;zzz&#x27;</span>), (<span class="string">&#x27;ttt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>insert  into与select</p>
<p>将新表的字段插入已有的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name(name) <span class="keyword">select</span> name <span class="keyword">from</span> new_table</span><br></pre></td></tr></table></figure>
<p>事实上，MySQL甚至不关心SELECT返回的列名。它使用的是 列的位置，因此SELECT中的第一列（不管其列名）将用来填充 表列中指定的第一个列，第二列将用来填充表列中指定的第二 个列，如此等等。这对于从使用不同列名的表中导入数据是非 常有用的。</p>
<p><strong>update语句</strong></p>
<p>update由三部分构成：</p>
<ul>
<li>表</li>
<li>列名+新值</li>
<li>过滤条件</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name</span><br><span class="line"><span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;new name&#x27;</span></span><br><span class="line"><span class="keyword">where</span> cust_id <span class="operator">=</span> <span class="string">&#x27;zzz&#x27;</span></span><br></pre></td></tr></table></figure>
<p>IGNORE关键字 如果用UPDATE语句更新多行，并且在更新这些 行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 （错误发生前更新的所有行被恢复到它们原来的值）。为即使是发 生错误，也继续进行更新，可使用IGNORE关键字，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> IGNORE customers</span><br></pre></td></tr></table></figure>
<h4 id="引擎简介"><a href="#引擎简介" class="headerlink" title="引擎简介"></a>引擎简介</h4><ol>
<li><p><code>InnoDB</code>是一个可靠的事务处理引擎，它不支持全文 本搜索; </p>
</li>
<li><p><code>MEMORY</code>在功能等同于MyISAM，但由于数据存储在内存（不是磁盘） 中，速度很快（特别适合于临时表）； </p>
</li>
<li><p><code>MyISAM</code>是一个性能极高的引擎，它支持全文本搜索， 但不支持事务处理。</p>
</li>
</ol>
<p>外键（用于 强制实施引用完整性）不能跨引擎，即使用一 个引擎的表不能引用具有使用不同引擎的表的外键。</p>
<h4 id="视图与sql复用"><a href="#视图与sql复用" class="headerlink" title="视图与sql复用"></a><strong>视图</strong>与sql复用</h4><p><strong>创建更新一个视图</strong></p>
<p>创建更新<code>productcustomers</code>视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> productcustomers <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">from</span> customers, orders,orderitems</span><br><span class="line"><span class="keyword">where</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">and</span> orderitems.order_num <span class="operator">=</span> orders.order_num</span><br></pre></td></tr></table></figure>
<p><strong>查询一个视图</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> productcustomers</span><br></pre></td></tr></table></figure>
<p>等价于===&gt;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">from</span> customers, orders,orderitems</span><br><span class="line"><span class="keyword">where</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">and</span> orderitems.order_num <span class="operator">=</span> orders.order_num</span><br></pre></td></tr></table></figure>


<p>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相 同的名字）。</p>
<p>对于可以创建的视图数目没有限制。</p>
<p>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造 一个视图。</p>
<p>视图不能索引，也不能有关联的触发器或默认值。 </p>
<p> 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句。</p>
<p>对视图进行<code>update类操作</code>会更新视图的基表，但是视图主要用于数据的检索而不是更新</p>
<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><strong>存储过程</strong></h4><p>有点像批处理</p>
<p>使用存储过程有3个主要的好处，即简单、安全、高性能。</p>
<p>存储过程的调用叫做CALL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> store_process_name()</span><br></pre></td></tr></table></figure>


<p><strong>创建存储过程</strong></p>
<p>用CREATE PROCEDURE productpricing()语 句定义。如果存储过程接受参数，它们将在()中列举出来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> store_process_name()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">Avg</span>(prod_price) <span class="keyword">as</span> avg_price</span><br><span class="line">	<span class="keyword">from</span> products</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>在MySQL处理这段代码时，它创建一个新的存储过程productpricing。没有返回数据，因为这段代码并未调用存储过程，这里只是为 以后使用而创建它。</p>
<p><strong>delimiter</strong>更换分隔符</p>
<p>end后分割符为<code>;</code>后面不能接sql语句，使用<code>delimiter</code>更换成其他分隔符如<code>//</code>可以进行sql</p>
<p><strong>“@“</strong>一个变量的标识符</p>
<p>MySQL支持IN（传递给存储过程）、OUT（从存 储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参 数。</p>
<p><strong>单独<code>OUT</code>案例</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> productprincing;</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> productprincing(<span class="keyword">out</span> min_price <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>), <span class="keyword">out</span> max_price <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>), <span class="keyword">out</span> avg_price <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">min</span>(prod_price)</span><br><span class="line">	<span class="keyword">into</span> min_price</span><br><span class="line">	<span class="keyword">from</span> products;</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">max</span>(prod_price)</span><br><span class="line">	<span class="keyword">into</span> max_price</span><br><span class="line">	<span class="keyword">from</span> products;</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">avg</span>(prod_price)</span><br><span class="line">	<span class="keyword">into</span> avg_price</span><br><span class="line">	<span class="keyword">from</span> products;</span><br><span class="line"><span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> productprincing(<span class="variable">@p1</span>, <span class="variable">@p2</span>, <span class="variable">@p3</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@p1</span>;</span><br></pre></td></tr></table></figure>
<p><strong><code>OUT</code>与<code>IN</code>集合</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> ordertotal;</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> ordertotal(</span><br><span class="line">	<span class="keyword">in</span> ordernum <span class="type">int</span>,</span><br><span class="line">	<span class="keyword">out</span> ototal <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">select</span> <span class="built_in">sum</span>(quantity <span class="operator">*</span> item_price)</span><br><span class="line"> <span class="keyword">into</span> ototal</span><br><span class="line"> <span class="keyword">from</span> orderitems</span><br><span class="line"> <span class="keyword">where</span> order_num <span class="operator">=</span> ordernum;</span><br><span class="line"><span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> ordertotal(<span class="number">20005</span>, <span class="variable">@total</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@total</span>;</span><br></pre></td></tr></table></figure>
<p>只有在存储过程内包含业务规则和智能处理时， 它们的威力才真正显现出来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">EXISTS</span> ordertotal;</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> ordertotal(</span><br><span class="line">	<span class="keyword">in</span> onumber <span class="type">int</span>,</span><br><span class="line">	<span class="keyword">in</span> taxable <span class="type">boolean</span>,</span><br><span class="line">	<span class="keyword">out</span> ototal <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">declare</span> taxrate <span class="type">int</span> <span class="keyword">default</span> <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">sum</span>(item_price<span class="operator">*</span>quantity)</span><br><span class="line">	<span class="keyword">from</span> orderitems</span><br><span class="line">	<span class="keyword">where</span> order_num <span class="operator">=</span> onumber</span><br><span class="line">	<span class="keyword">into</span> total;</span><br><span class="line">	if taxable <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">select</span> total <span class="operator">+</span> total <span class="operator">/</span> <span class="number">100</span> <span class="operator">*</span> taxrate <span class="keyword">into</span> total;</span><br><span class="line">	<span class="keyword">end</span> if;</span><br><span class="line">	<span class="keyword">select</span> total <span class="keyword">into</span> ototal;</span><br><span class="line"><span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> ordertotal(<span class="number">20005</span>, <span class="number">1</span>, <span class="variable">@ototal</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@ototal</span>;</span><br><span class="line"><span class="keyword">call</span> ordertotal(<span class="number">20005</span>, <span class="number">0</span>, <span class="variable">@ototal</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@ototal</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> status</span><br></pre></td></tr></table></figure>


<h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><p><code>游标（cursor）</code>是一个存储在MySQL服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。</p>
<p><code>MySQL游标</code>只能用于 存储过程（和函数）。</p>
<p><strong>游标的创建与使用</strong></p>
<ul>
<li>创建语句：<code>declare cursor_name cursor for</code></li>
<li>使用游标：<code>open cursor_name</code></li>
<li>获取下一行数据：<code>fetch cursor_name</code></li>
<li>关闭游标：<code>close cursor</code>(默认在存储过程的end时关闭游标)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> processorders;</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> processorders(<span class="keyword">out</span> output <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> ordernumbers <span class="keyword">cursor</span></span><br><span class="line">	<span class="keyword">for</span></span><br><span class="line">	<span class="keyword">select</span> order_num <span class="keyword">from</span> orders;</span><br><span class="line">	<span class="keyword">open</span> ordernumbers;</span><br><span class="line">	<span class="keyword">fetch</span> ordernumbers <span class="keyword">into</span> output;</span><br><span class="line"><span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> processorders(<span class="variable">@output</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@output</span>;</span><br></pre></td></tr></table></figure>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>响应<code>update</code>、<code>insert</code>、<code>delete</code>语句并触发一个语句执行</p>
<p>mysql中触发器名必 须在每个<strong>表中</strong>唯一，其他dbms不一定统一</p>
<p>只有表才支持触发器，视图不支持（临时表也不 支持）。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>MyISAM和InnoDB是两种最常使用 的引擎。前者不支持明确的事务处理管理，而后者支持。</p>
<p>事务处理是一种 机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完 整的操作结果。</p>
<p>利用事务处理，可以保证一组操作不会中途停止，它们 或者作为整体执行，或者完全不执行（除非明确指示）。</p>
<ul>
<li>事务（transaction）：一组sql</li>
<li>回退（rollback）</li>
<li>提交（commit）</li>
<li>保留点（savepoint）：指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>你不能回退CREATE或DROP操作。事务处理块中可以使用 这两条语句，但如果你执行回退，它们不会被撤销。</p>
<p>**隐含事务关闭 **：当COMMIT或ROLLBACK语句执行后，事务会自 动关闭</p>
<h4 id="字符集问题"><a href="#字符集问题" class="headerlink" title="字符集问题"></a>字符集问题</h4><p>数据库表被用来存储和检索数据。不同的语言和字符集需要以不同 的方式存储和检索。</p>
<ul>
<li><code>字符集</code>为字母和符号的集合；</li>
<li><code>编码</code>为某个字符集成员的内部表示</li>
<li><code>校对</code>为规定字符如何比较的指令</li>
</ul>
<p>不同的表，甚至不同的列都可能需要不同的字符集，而且两者都 可以在创建表时指定。</p>
<h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><p>应该严肃对待root登录的使用。仅在绝对需 要时使用它（或许在你不能登录其他管理账号时使用）。不应 该在日常的MySQL操作中使用root。</p>
<p>MySQL用户账号和信息存储在名为<code>mysql</code>的MySQL数据库中</p>
<p>mysql数据库管理系统采用一个数据库记录所有的用户信息</p>
<p><strong>创建用户</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> user_name identified <span class="keyword">by</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>查看用户权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> user_name;</span><br></pre></td></tr></table></figure>
<p><strong>赋予权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> database1.<span class="operator">*</span> <span class="keyword">to</span> zgz;</span><br></pre></td></tr></table></figure>
<p>此语句为名为<code>zgz</code>的用户在<code>database1</code>数据库中赋予<code>select</code>的权利</p>
<p><strong>更换口令</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> zgz <span class="operator">=</span> Password(<span class="string">&#x27;new_password&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><h4 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h4><ul>
<li>总是有不止一种方法编写同一条SELECT语句。应该试验联结、并、 子查询等，找出最佳的方法。</li>
<li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL 语句快。 </li>
<li>应该总是使用正确的数据类型。</li>
<li>决不要检索比需求还要多的数据。换言之，不要用SELECT *（除 非你真正需要每个列）。</li>
<li>必须索引数据库表以改善数据检索的性能。</li>
<li>索引改善数据检索的性能，但损害数据插入、删除和更新的性能。</li>
<li>你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条 SELECT语句和连接它们的UNION语句，你能看到极大的性能改 进。</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><code>distinct</code>：用于过滤出不一样的select结果</p>
<p>MySQL 5支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title>problem-windi-vue</title>
    <url>/2021/06/05/problem-windi-vue/</url>
    <content><![CDATA[<h1 align="center">
    vscode windicss插件使用中的问题
</h1>


<p>此片文章从开始使用vscode    windicss插件开始记录，记录个人碰到的一些问题，可能会对他人有所帮助，但是其中bug可能会在未来某天被官网解决。</p>
<h2 id="1-config-with-vscode-auto-rename-tag（插件冲突导致不能提示）"><a href="#1-config-with-vscode-auto-rename-tag（插件冲突导致不能提示）" class="headerlink" title="1. config with vscode-auto-rename-tag（插件冲突导致不能提示）"></a>1. config with <code>vscode-auto-rename-tag</code>（插件冲突导致不能提示）</h2><p>2021/6/5</p>
<p>this extension conflicts with <a href="https://github.com/formulahendry/vscode-auto-rename-tag">vscode-auto-rename-tag</a>.<br>disable the auto-rename-tag and restart vscode, the windicss intellisense works fine.</p>
<p><a href="https://github.com/windicss/windicss-intellisense/issues/113">github issue源地址</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>typescript中的协变、逆变</title>
    <url>/2021/09/20/ts-variance/</url>
    <content><![CDATA[<h1 id="typescript中的协变、逆变"><a href="#typescript中的协变、逆变" class="headerlink" title="typescript中的协变、逆变"></a>typescript中的协变、逆变</h1><blockquote>
<p>​    想要写出更加优秀的类型编程co-variance（协变）contra-variance（逆变）这类知识是我们必须掌握的。这篇记录也仅仅是为了方便之后哪天这块知识在应用过程中出现问题后，能够根据此篇，来快速定位编写代码中的问题。这篇也仅仅是一些学习资料的记录。文中许多表述，都是个人的理解毕竟本人学历较低英语水平较差，资料中的表述多有理解不充分的地方。</p>
</blockquote>
<p><a href="https://www.youtube.com/watch?v=EInunOVRsUU">资料的源链</a>（需要科学上网）</p>
<p>首先我们需要知道以下的概念。在泛型编程中泛型参数会影响类型泛型的关系。</p>
<p>出于<code>ts</code>采用的是结构类型系统，这里我们用 <code>subtype</code> 来表示来表示可分配的关系。泛型参数引起的协变、逆变都是设计者出于类型安全性的问题而设计的。</p>
<p>以下的例子我们都以<code>Dog</code>、<code>Animal</code>为基本类型,根据类型关系<code>Dog extends Animal</code> 进行分析</p>
<p>定义中以<code>List&lt;T&gt;</code> 来阐述关系</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h4 id="co-variance定义"><a href="#co-variance定义" class="headerlink" title="co-variance定义"></a>co-variance定义</h4><p>在<code>Dog is subtype of Animal</code>的情况下，<code>List&lt;Dog&gt; is subtypeof List&lt;Animal&gt;</code>我们称这种<code>List&lt;T&gt;</code>泛型变化为协变</p>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/ts/variance/ts.png"></p>
<h4 id="contra-variance定义"><a href="#contra-variance定义" class="headerlink" title="contra-variance定义"></a>contra-variance定义</h4><p>在<code>Dog is subtype of Animal</code>的情况下，<code>List&lt;Animal&gt; is subtypeof List&lt;Dog&gt;</code> 我们称这种<code>List&lt;T&gt;</code>泛型变化为逆变</p>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/ts/variance/ts2.png"></p>
<h4 id="in-variance定义（这里的我们可以理解为独立类型）"><a href="#in-variance定义（这里的我们可以理解为独立类型）" class="headerlink" title="in-variance定义（这里的我们可以理解为独立类型）"></a>in-variance定义（这里的我们可以理解为独立类型）</h4><p>在<code>Dog is subtype of Animal</code>的情况下，<code>List&lt;Animal&gt; 与 List&lt;Dog&gt;</code> 没有什么关系</p>
<h4 id="bi-variance定义（能够相互赋值）"><a href="#bi-variance定义（能够相互赋值）" class="headerlink" title="bi-variance定义（能够相互赋值）"></a>bi-variance定义（能够相互赋值）</h4><p>在<code>Dog is subtype of Animal</code>的情况下，<code>List&lt;Animal&gt; 与 List&lt;Dog&gt;</code> 能够相互赋值</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> List&lt;T&gt; = T[]</span><br><span class="line"><span class="keyword">const</span> animals:List&lt;Animal&gt; = [] <span class="keyword">as</span> List&lt;Animal&gt;</span><br><span class="line"><span class="keyword">const</span> dogs:List&lt;Dog&gt; = animals      <span class="comment">//no error</span></span><br><span class="line"><span class="keyword">const</span> animals2: List&lt;Animal&gt; = dogs <span class="comment">//no error</span></span><br></pre></td></tr></table></figure>
<p>做完这些定义我们可以看几个例子以此来搞明白这么做有什么意义。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//base types</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> weight = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> isGoodBoy = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;wofi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> isPlotting: <span class="string">&quot;yes&quot;</span> | <span class="string">&quot;no&quot;</span> = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">play</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;miau&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cage&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> animal: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dogCage: Cage&lt;Dog&gt; = &#123; <span class="attr">animal</span>: <span class="keyword">new</span> Dog() &#125;;</span><br><span class="line"><span class="keyword">let</span> cage: Cage&lt;Animal&gt; = dogCage; <span class="comment">//这里类型安全因为Animal是关系链的最高级，所有与之有关的对象都是对其进行扩展</span></span><br><span class="line"><span class="keyword">let</span> catCage: Cage&lt;Cat&gt; = cage; <span class="comment">//这里cage实际已经被之前的操作换成了dogCage,并且ts编译器已检查出了错误</span></span><br><span class="line">catCage.animal.play(); 		   <span class="comment">//假设我们让编译通过，catCage中存在的其实是dog对象，不存在play方法，因此类型不安全</span></span><br></pre></td></tr></table></figure>
<p>例1说明<code>readonly</code>的<code>field</code>引起泛型关系的<code>co-variance</code></p>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Mother&lt;T&gt; &#123;</span><br><span class="line">  create: <span class="function">() =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dogMother: Mother&lt;Dog&gt; = &#123;</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> animationMother: Mother&lt;Animal&gt; = dogMother;<span class="comment">//success</span></span><br><span class="line"><span class="keyword">let</span> catMother: Mother&lt;Cat&gt; = animationMother; <span class="comment">//error:&#x27;Mother&lt;Animal&gt;&#x27; is not assignable to type &#x27;Mother&lt;Cat&gt;&#x27;</span></span><br><span class="line">catMother.create().play(); <span class="comment">//与例1相同狗狗被当成猫对待类型不安全=&gt;return type是co-variance</span></span><br></pre></td></tr></table></figure>
<p>例2说明<code>function signature(函数签名)</code>方法的<code>return type</code>引起泛型关系的<code>contra-variance</code></p>
<h4 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例3</span></span><br><span class="line"><span class="keyword">interface</span> Groomer&lt;T&gt; &#123;</span><br><span class="line">  cuthair: <span class="function">(<span class="params">animal: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dogGroomer: Groomer&lt;Dog&gt; = &#123;</span><br><span class="line">  <span class="function"><span class="title">cuthair</span>(<span class="params">dog</span>)</span> &#123;</span><br><span class="line">    dog.bark(); <span class="comment">//这里调用了子类独有的操作狗叫</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> animalGroomer: Groomer&lt;Animal&gt; = dogGroomer; <span class="comment">//Error: 因为狗狗是对animal的拓展，animal中不存在bark方法</span></span><br><span class="line">animalGroomer.cuthair(<span class="keyword">new</span> Animal()); <span class="comment">//这里假设能进行编译，运行时将会有 dog.bark is not a function报错</span></span><br><span class="line"><span class="keyword">let</span> animalGroomer2: Groomer&lt;Animal&gt; = &#123;</span><br><span class="line">  <span class="function"><span class="title">cuthair</span>(<span class="params">animal</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.weight); <span class="comment">//所有的动物都具有的weight，所以猫猫也可以cuthair</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> catGroomer: Groomer&lt;Cat&gt; = animalGroomer2; <span class="comment">//当方法参数的变化引起contra-variance</span></span><br></pre></td></tr></table></figure>
<p>例子3说明<code>function signature(函数签名)</code>方法的参数位引起泛型关系的`contra-variance</p>
<h4 id="得出一个普遍结论"><a href="#得出一个普遍结论" class="headerlink" title="得出一个普遍结论"></a>得出一个普遍结论</h4><ul>
<li>1.由方法实现产出的为co-variance </li>
<li>2.参与到方法实现中的为cotra-variance</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>针对函数参数位，我在上面写下结论的时候有带上<code>function signature(函数签名)</code>的字样</p>
<p>那什么是方法签名呢？</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> lll &#123;</span><br><span class="line">	methods(): <span class="built_in">void</span>;           	<span class="comment">//method signature</span></span><br><span class="line">	functions: <span class="function">() =&gt;</span> <span class="built_in">void</span>;		<span class="comment">//function signature</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使这两种表示产生类型编程时的不同，我们需要<code>--strictFunctiontypes</code>，这是<code>针对于函数参数位</code>的检查<code>function signature</code>会采用更加严格的方式</p>
<ol>
<li><code>strictFunctiontype</code> 只会影响<code>function signatures</code>，所以method signature是bi-variance,例如：lib.es5.ts库中类似Array其中的method signature不受到<code>strictFunctiontype</code>影响</li>
<li>contra-variance - when used in function signatures with strictFunctiontype(使用function signature引起逆变)</li>
<li>bi-variance - when used in function signatures without strictFunctiontype</li>
<li>bi-variance - when used in method signatures</li>
</ol>
<h4 id="为什么在参数位置的variance这么复杂？"><a href="#为什么在参数位置的variance这么复杂？" class="headerlink" title="为什么在参数位置的variance这么复杂？"></a>为什么在参数位置的variance这么复杂？</h4><p>为了js的用户群里能更快的迁移是其中的一点，针对老练的玩家可以使用<code>strictFunctiontype</code>编写出更加优秀的类型代码，而针对初级玩家就可以规避这些编译问题。</p>
<h4 id="类型编程建议"><a href="#类型编程建议" class="headerlink" title="类型编程建议"></a>类型编程建议</h4><ol>
<li>可以更多地使用readonly</li>
<li>更多地使用function signatures</li>
<li>在接口中考虑variance<ol>
<li>优先 co / contra variance</li>
<li>其次使用invariance</li>
<li>尽可能少的bi-variance</li>
</ol>
</li>
</ol>
<p>bi-variance虽然不会给你带来很多红色的波浪线但是类型编程带来的程序维护性的收益也就更低。</p>
<p>比如将例子3进行更改</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例3</span></span><br><span class="line"><span class="keyword">interface</span> Groomer&lt;T&gt; &#123;</span><br><span class="line">  cuthair(animal: T): <span class="built_in">void</span>; <span class="comment">//这里从原来的function signature改为method signature</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dogGroomer: Groomer&lt;Dog&gt; = &#123;</span><br><span class="line">  <span class="function"><span class="title">cuthair</span>(<span class="params">dog</span>)</span> &#123;</span><br><span class="line">    dog.bark(); <span class="comment">//这里调用了子类独有的操作狗叫</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> animalGroomer: Groomer&lt;Animal&gt; = dogGroomer;</span><br><span class="line">animalGroomer.cuthair(<span class="keyword">new</span> Animal()); <span class="comment">//这里已经不会有类型检查的报错了，但是运行时将会有 dog.bark is not a function报错</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ts</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>从建立建立socket连接看三次握手</title>
    <url>/2021/09/11/tcp-ip/</url>
    <content><![CDATA[<blockquote>
<p>​    本文任然是对于当前阅读的一个知识梳理，衔接前文<a href="https://sunboyzgz.github.io/2021/09/09/what-happend-when--press-enter/">了解在地址输入栏中简单的按下一个回车背后复杂的故事</a>，上文讲到通过建立<code>socket</code>从DNS服务器拿到域名解析后的地址<code>ip</code>，但是该过程是一个基于<code>udp</code>协议的传输。而我今天梳理的是一种基于<code>tcp</code>协议的传输。</p>
</blockquote>
<p>基于<code>udp</code>的传输：只负责包的发出和接受</p>
<p>基于<code>tcp</code>的传输：在<code>udp</code>的<strong>功能基础</strong>之上，提供了一些丢包判断的机制，以及丢包重传的机制。</p>
<p>在网络传输的过程中，往往会发生一些包丢的问题，基于<code>tcp</code>协议的网络传输更加严谨相比于基于<code>udp</code>的传输，更加严谨，它提供了一些丢包判断的机制，以及丢包重传的机制。</p>
<h1 id="正题开始"><a href="#正题开始" class="headerlink" title="正题开始"></a>正题开始</h1><p>建立一次<code>tcp</code>连接我们首先应该从，套接字的创建开始讲，首先我们需要知道下面的概念：</p>
<ol>
<li><p>套接字：我们首先需要建立一条可靠的”网络线路”，这条网络线路是需要客户端与服务端两边提供可以相互连接的套接字才能成功建立。 <strong>套接字并非实体</strong>。</p>
</li>
<li><p>客户端：我们可以简单的理解发出请求并需要服务端提供响应的就是客户端。</p>
<p>服务端：根据客户端的请求提供响应。</p>
</li>
<li><p>套接字相互识别：服务端套接字与客户端套接字需要一个相互机制才能建立<code>tcp</code>连接。</p>
</li>
<li><p>如果说<code>描述符</code>是用来在一台计算机内部识别套接字的机制，那么<code>端口号</code>就是用来让通信的另一方能够识别出套接字的机制。</p>
</li>
<li><p>….</p>
</li>
</ol>
<p><strong>此图来源《网络是怎样连接的》</strong></p>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/tcp-ip/%E5%BA%94%E7%94%A8-%E5%8D%8F%E8%AE%AE%E6%A0%88-%E7%A1%AC%E4%BB%B6.jpg" alt="此图来源：《网络是怎样连接的》"></p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>下面我们来说一说通过套接字建立的过程。</p>
<ol>
<li>服务器端调用Socket库创建一个套接字并监听某个端口等待客户端连接。</li>
<li>就浏览器客户端来说，使用解析<code>url</code>获得的<code>ip</code>以及提前知道的服务器端口号，就如浏览器默认http协议使用80端口一样。</li>
<li>找到端口后监听可靠性连接，俗称三次握手</li>
</ol>
<p>我们可以使用下面我们比较熟悉的方式来进行理解</p>
<p><strong>伪代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;服务端</span><br><span class="line">socket&lt;描述符&gt; &#x3D; Socket()</span><br><span class="line">socket&lt;描述符&gt;.listen(80, () &#x3D;&gt; &#123;do something ...&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端</span><br><span class="line">socket&lt;描述符&gt; &#x3D; Socket(ip, port)</span><br><span class="line">socket&lt;描述符&gt;.connect()</span><br></pre></td></tr></table></figure>
<p>上面代码的socket就充当了<code>描述符</code>的作用，<code>描述符</code>记录了与通信相关的一些信息，使用<code>描述符</code>就能让我们在发起多个不同的请求时，不会错误连接。</p>
<p>然后我们具体关注<code>socket.connect()</code>这部分的内容</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>一段请求数据在经过<code>tcp</code>模块后会被包装上<code>tcp</code>头部。具体的格式与内容可以百度。</p>
<p>三次握手主要是通过控制位的真值进行操作，具体操作<code>ACK</code>,<code>SYN</code></p>
<ol>
<li>客户端向服务器发出第一次连接请求：<code>tcp</code>头部中包括<code>发出方</code>端口号，<code>接受方</code>端口号，<code>控制位信息</code>，等信息。<strong>服务器返回一段数据包给客户端</strong>，其中<code>tcp</code>头部<code>控制位信息</code>的<code>SYN</code>位设为1,<code>ACK</code>位设为1。相当于告知客户端：“我收到了你的信号”。相当于完成第一次握手。</li>
<li>客户端收到服务器返回的信号，但是服务器此时并不知道客户端能够收到他的消息，所以客户端需要再次发送一段数据包给服务端，告诉服务端它能够收到信号，这段数据包中<code>tcp</code>头部<code>控制位信息</code>的<code>SYN</code>位设为1,<code>ACK</code>位设为1。相当于告诉服务器：“我也能收到你的信号”。此时完成了第二次握手。</li>
<li>最终服务器收到了客户端的第二个信号。服务端就知道他能够和客户端双向传输了。此时完成了三次握手。</li>
</ol>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/tcp-ip/tcp_ip%20%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91.png"></p>
<p>在三次握手之后就是数据的收发了。</p>
<p>在这里不知道有没有发现上面客户端第一次发出消息那行说了：“<code>tcp</code>头部中包括<code>发出方</code>端口号”。这里我们并没有设置端口号啊，那这个端口号怎么来的呢。原来我们我们进行socket调用系统就会为我们随机分配一个有效端口号，这个有效端口应是小于16位的，具体可百度，这个端口号会被存入描述符的地址空间。然后我们请求时就都会使用这个端口进行操作。</p>
<p>完成收发应当是四次挥手了</p>
<h4 id="断开"><a href="#断开" class="headerlink" title="断开"></a>断开</h4><p><strong>四次挥手</strong></p>
<p>四次挥手与三次握手类似，主要控制控制位的<code>FIN</code> <code>SYN</code>位。</p>
<p>具体过程</p>
<ol>
<li>服务器完成所有的数据发送，首先发出断开请求此时讲<code>FIN</code>位设为1，给客户端返回断开信息</li>
<li>客户端就收到服务器的断开信息并给服务器发送ACK（这个ACK是用来标识收到了多少个字节数据的），用于完整性校验</li>
<li>客户端发出断开请求此时讲<code>FIN</code>位设为1，给客户端返回断开信息</li>
<li>服务端收到客户端你的断开信息并给服务器发送ACK</li>
</ol>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/tcp-ip/tcp_ip%20%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%20(1).png"></p>
<p>断开的最后会删除两端套接字，这样从建立连接到断开连接就结束了。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>first learning of rollup</title>
    <url>/2021/05/31/try-rollup/</url>
    <content><![CDATA[<h1 align="center">
    初次学习rollup
</h1>  

<p>因为最近在学习<code>vite</code>的使用和一些与开源相关的知识，最终还是打算把这个技术栈（债）补上😂</p>
<h4 id="为什么要学习rollup"><a href="#为什么要学习rollup" class="headerlink" title="为什么要学习rollup"></a>为什么要学习rollup</h4><p><a href="https://rollupjs.org/guide/en/">rollup</a>作为一款优秀的打包工具，同时提供cli、配置文件、js脚本执行的打包方式</p>
<p>同时它也实现了<code>tree-shaking</code>的支持</p>
<p>虽然在大型应用开发过程中的开发体验不及webpack，但是它用在打包一些小的工具库、开源包方面十分优秀</p>
<p>不过值得一提的是<a href="https://vitejs.dev/">vite</a>在打包方面采用了<code>rollup</code>，同时<code>vite</code>对<code>rollup</code>提供的接口进行了些许扩展，并且部分的rollup插件也已经实现了对<code>vite</code>的支持，<code>vite</code>的开发时体验是非常优秀的，足以弥补<code>rollup</code>开发时的不足之处</p>
<hr>

<h4 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h4><p><code>inputOptions</code>:</p>
<ul>
<li>external</li>
<li>input</li>
<li>plugins</li>
<li>………………</li>
</ul>
<p><code>outputOptions</code>:</p>
<ul>
<li>dir</li>
<li>file</li>
<li>format</li>
<li>globals</li>
<li>name</li>
<li>plugins</li>
</ul>
<p><code>rollup</code>中 命令行输入\ 配置文件\ <code>js Api</code>之间存在一定的对应关系如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rollup.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    input: <span class="string">&#x27;src/main.js&#x27;</span>,</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build_script.js</span></span><br><span class="line"><span class="keyword">const</span> rollup = <span class="built_in">require</span>(<span class="string">&#x27;rollup&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">require</span>(<span class="string">&#x27;rollup.config.js&#x27;</span>).input</span><br><span class="line"><span class="keyword">const</span> inputOptions = &#123; input &#125;</span><br><span class="line"><span class="keyword">const</span> outputOptions = &#123; ………… &#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bunld = <span class="keyword">await</span> rollup.rollup(inputOptions)</span><br><span class="line">    <span class="keyword">await</span> bundle.generate(outputOptions)</span><br><span class="line">   	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rollup -i ./src/main.js -f cjs</span><br></pre></td></tr></table></figure>
<p>但并不是所有的指令与配置项都存在对应,<a href="https://rollupjs.org/guide/en/#command-line-flags">源链解释</a></p>
<hr/>

<h4 id="rollup-与-npm-集成"><a href="#rollup-与-npm-集成" class="headerlink" title="rollup 与 npm 集成"></a>rollup 与 npm 集成</h4><p>当一个要被打包的文件的导入模块中存在<code>npm</code>包，rollup并不知道要在<code>node_modules</code>中找到对应的文件</p>
<p> <a href="https://github.com/rollup/rollup-plugin-node-resolve">rollup-plugin-node-resolve</a>：告诉rollup如何找到对应导入的<code>npm</code></p>
<p><a href="https://github.com/rollup/rollup-plugin-commonjs">rollup-plugin-commonjs</a>：使得cjs规范的<code>npm</code>能转换为es2015供<code>rollup</code>处理</p>
<hr/>

<h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p><a href="https://github.com/rollup/awesome">https://github.com/rollup/awesome</a></p>
<p>plugin开发规范：<a href="https://rollupjs.org/guide/en/#conventions">https://rollupjs.org/guide/en/#conventions</a></p>
<p>一个<code>rollup插件</code>就是 一个符合规范的 + 带有<code>rollup</code>实现的钩子的对象</p>
<ul>
<li><p>插件钩子带有 kind(async, first, sequential, parallel)决定了他们的执行方式</p>
</li>
<li><p>rollup在不同的工作时期具有许多的钩子如：</p>
<p><code>rollup.rollup</code>激活<code>build</code>部分的钩子</p>
<p><code>bundleObj.generate</code>激活<code>ouput generation</code>部分的钩子，同时不同工作时期中的不同钩子也具有一定顺序</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title>图解地址栏按下回车后到底发生了什么</title>
    <url>/2021/09/09/what-happend-when--press-enter/</url>
    <content><![CDATA[<blockquote>
<p>如何让阅读后进入脑中的知识点更加有体系，如何让抽象的知识变的更加活灵活现，阅读后的梳理可以让我们更好地做到这一点。同时实践能够让我们更加清楚地了解新知识的应用场景。这篇便是我学习网络的初章。</p>
</blockquote>
<h1 id="了解在地址输入栏中简单的按下一个回车背后复杂的故事"><a href="#了解在地址输入栏中简单的按下一个回车背后复杂的故事" class="headerlink" title="了解在地址输入栏中简单的按下一个回车背后复杂的故事"></a>了解在地址输入栏中简单的按下一个回车背后复杂的故事</h1><p>在了解本文主题之前我们不妨花上小几分钟简单阅读一下一下的内容，或许会有新的收获</p>
<p>1.浏览器的各种访问目标统称为URI</p>
<p>2.尽管浏览器能够解析网址并生成HTTP消息，但它本身并不具备将消息发送到网络中的功能，因此这一功能需要委托操作系统来实现</p>
<p>3.仅凭32位 的IP我们无法区分哪部分是网络号，哪部分是主机号。ip=网络号（xx小区）+主机号（xx室）</p>
<p>4  <strong>!</strong> 主机号部分<code>bit</code>全为0，表示一个<code>子网</code>如<code>192.168.1.0</code>, <code>192.168.0.0</code></p>
<p>​    <strong>!</strong> 主机号部分<code>bit</code>全为1，表示一个子<code>网内广播地址</code>如<code>192.168.1.255</code>, <code>192.168.0.255</code></p>
<p>5.子网掩码为1的部分表示网络号，子网掩码为0的部分表示主机号。</p>
<p>6.子网掩码表示网络号与主机号之间的边界</p>
<p>7.在域名中，越靠右的位置表示其层级越高，比如<a href="http://www.lab.glasscom.com这个域名如果按照公司里的组织结构来说,大概就是“com事业集团glasscom部lab科的www”这样./">www.lab.glasscom.com这个域名如果按照公司里的组织结构来说，大概就是“com事业集团glasscom部lab科的www”这样。</a></p>
<p>8.服务器一方先创建套接字，然后等待客户端向该套接字连接管道</p>
<p>9.如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制</p>
<p>10.客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。接下来，当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。</p>
<h1 id="正题开始"><a href="#正题开始" class="headerlink" title="正题开始"></a>正题开始</h1><p>​        首先我们都知道<code>url</code>并不是网络通信中真正有效的信息，在网络中我们通过<code>ip</code>来确认目的地服务器，当我们获取到<code>ip</code>后，会将<code>ip</code>等用于网络数据传输的信息一并交给操作系统的协议栈。</p>
<p>​        这里有一点基础的概念：我们建立在操作系统之上的应用程序并不能之间进行与硬件的沟通，一切应用对于硬件的操作都要通过操作系统调用，不能想当然的认为是应用操作了硬件，显然网络的通信是需要硬件支撑的。</p>
<p>​        ok，那么我们怎么才能知道目的地的<code>ip</code>呢，答案就是解析你输入的<code>url</code>,就好比电话号码我们不可能记住身边每一个人的电话号码，因为它是并不存在具体的含义。而我们常用的电话簿就用简单易记的名字或者绰号对应了电话号码，比如我们可以轻松的点击”二狗”的头像并联系他。</p>
<p><code>ip</code> -&gt; 电话号码 , <code>url</code> -&gt; 你对好友的备注,  <code>?</code> -&gt; 电话簿</p>
<p>问：<code>?</code>处应填入什么？    答案：DNS服务器</p>
<p>当然，这样形容并不是完全正确，因为在一方面电话簿是一个本地的记录，而DNS不存在于本地。但是就理解来说已经非常易懂了。</p>
<p>好的那么我们开始讲讲浏览器是如何通过远程访问将<code>ip</code>这一信息拿到手的吧。这里我们值得一说的是我们会忽略一些细节，比如去浏览器解析缓存中存在的<code>url</code>-&gt;<code>ip</code>映射，<code>dns</code> 建立<code>udp</code>通信等并不主要的内容</p>
<h4 id="图解ip获取的过程"><a href="#图解ip获取的过程" class="headerlink" title="图解ip获取的过程"></a>图解ip获取的过程</h4><p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/what-happend-when-press-enter/%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8.png"></p>
<p>我们主要将目光放在去向DNS服务器的这条路线上。</p>
<ol>
<li>首先应用程序会使用系统提供的Socket库创建套接字。在这里我们可以这样思考：为什么我们发出请求到服务器服务器就能给我们响应呢，是因为服务早早就让自己那端创建了一个套接字，当然套接字只是一个抽象的概念，只并不存在实体。然后服务端那边的套接字就一直等着另一个套接字与之连接。就像是管道一样能够传输其中的数据流。</li>
</ol>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/what-happend-when-press-enter/%E5%A5%97%E6%8E%A5%E5%AD%97.png"></p>
<p>2.那客户端应该如何去识别他要接入的套接字呢。这些都需要使用到库中的<code>解析器</code>。他会根据输入的<code>url</code>提取出有用的信息比如: <code>端口号</code>。平时我们的浏览器进行网页访问的时候都是直接输入一串<code>url</code>，而不用去设置端口号这是因为浏览器访问http请求默认使用80端口。</p>
<p>3.那服务器的套接字我们能够分辨出来了，而客户端可能会有多个应用同时对不同的服务端发出请求，怎么样才能让不同的应用找到自己创建的套接字呢？换句话说就是规避数据传输混乱的问题呢，这里就要使用到创建套接字时生成的描述符了。我们只需要知道这相当于是一个套接字的标识即可。</p>
<p>如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制</p>
<p>此篇仅为阅读《网络是怎样连接的》一书第一章知识的简单梳理。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>typescript reference to global</title>
    <url>/2021/05/20/typescript-global/</url>
    <content><![CDATA[<center><h1>
    TS扩展全局变量类型推导
    </h1></center>

<blockquote>
<p>​    写这篇文章是因为我在学习vben项目时，在global文件的定义时出现了种种问题，但是在网上又不能及时找到合适的对策</p>
</blockquote>
<h4 id="前提概念"><a href="#前提概念" class="headerlink" title="前提概念"></a>前提概念</h4><ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#introductio">声明合并(Declartion Merging)</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation">全局变量如何定义？</a></li>
</ul>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>然后我们定义一个<code>global.d.ts</code>文件<img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/typescript-global/Snipaste_2021-05-20_15-02-05.png"></p>
<p>这是我们定义好了全局的一些变量推导，但是我们ts的检查显示我们出现了一些问题，以下为具体的报错信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Augmentations for the global scope can only be directly nested in external modules or ambient module declarations</span><br></pre></td></tr></table></figure>
<p>这里的报错是说全局作用域的只能被直接嵌套在内部模块或者已经存在的模块定义文件中</p>
<p>显然我们是想定义一个定义文件的</p>
<p>在TS官网有这样的一段话</p>
<p><a href="https://www.typescriptlang.org/docs/handbook/2/modules.html#non-modules">https://www.typescriptlang.org/docs/handbook/2/modules.html#non-modules</a></p>
<blockquote>
<p>​    Before we start, it’s important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an <code>export</code> or top-level <code>await</code> should be considered a script and not a module.</p>
<p>……</p>
<p>If you have a file that doesn’t currently have any <code>import</code>s or <code>export</code>s, but you want to be treated as a module, add the line:</p>
</blockquote>
<p>因此我们可以在文件的第一行加上<code>export &#123;&#125;</code></p>
<p>但是这是我们仍然存在报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#39;declare&#39; modifier cannot be used in an already ambient context.ts(1038)</span><br></pre></td></tr></table></figure>
<p>这里的意思是我们在一个已经存在的模块中使用了<code>declare</code>，其实也很容易明白，因为<code>global</code>作用域作用在全局，应该是一个内置的模块</p>
<p>那么现在我想到的就有两种方案：</p>
<ul>
<li>删除<code>declare</code> （我认为的正确做法）</li>
<li><code>tsconfig.json</code>文件配置<code>skipLibCheck: true</code> <a href="https://www.typescriptlang.org/tsconfig#skipLibCheck">skipLibCheck链接</a>（vben中采用的方式）</li>
</ul>
<p>如果采用第一种方案,此时已经可以得到正确结果</p>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/typescript-global/Snipaste_2021-05-20_15-50-31.png"></p>
<p>如果使用第二种方案，这个时候在我们的文件中仍然不能正确的找到推到结果</p>
<p><img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/typescript-global/Snipaste_2021-05-20_14-22-34.png"></p>
<p>产生这个的原因与我的文件结构和<code>tsconfig.json</code>配置有关</p>
<p>目录结构</p>
<img src="https://blog-zgz.oss-cn-hangzhou.aliyuncs.com/typescript-global/Snipaste_2021-05-20_16-02-29.png" />

<p>因此我们要在<code>tsconfig.json</code>中的<code>include</code>中加入我们对全局可以引用的文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;, &quot;build/**/*.ts&quot;, &quot;types/**/*.d.ts&quot;]</span><br></pre></td></tr></table></figure>
<p>然后开启<code>skipLibCheck</code>消除报错，就可实现推导了</p>
<p>2021/6/3-<code>skipLibCheck</code>的实际作用：启用它会阻止Typescript对整个导入的库进行类型检查。相反，Typescript只会针对这些类型对您使用的代码进行类型检查。这意味着只要您不使用导入库的不兼容部分，它们就可以正常编译。<code>--skipLibCheck</code>会降低类型检查的能力，理想情况下我们不会使用它。但是并不是每个库都提供完美的类型，因此跳过它可能会很好。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
